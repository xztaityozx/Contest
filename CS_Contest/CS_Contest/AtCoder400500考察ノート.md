AtCoder 400,500考察ノート
# ABC051 D Candidates of No Shortest Paths
- ワーシャルフロイドで全点間距離を求める
- 入力された`edge[i,j]`が使われているかどうかは、各点sから
    - ```distance[s,i] + edge[i,j].Cost == distance[s,j]```
- を調べる。

# ABC054 D Mixing Experiment
- 典型的なDP
- `dp[N,aiの合計,biの合計] = 最小コスト `
- `dp[i+1,i,j] = Min(dp[i,j,k],dp[i+1,j,k])`
- `dp[i+1,i+ai,j+bi] = Min(dp[i,j,k]+ci,dp[i+1,j+ai,k+bi])`

# ABC057 D Maximum Average Sets
- DPっぽいけど違った
- `v`を降順にソートし先頭からA個の平均が最大値（これは自明）
    - A+1個目を足しても平均は下がる一方（降順に並んでるから）
- v[0]とv[A-1]が同じ値のとき
    - 最大値がA個以上続いているかもしれない
    - vの中にv[A-1]がX個あるとき
    - 組み合わせ`XCi` `(A<=i<=B)`の合計が答え
- v[0]とv[A-1]が違うとき
    - 先頭からA個のうちにv[A-1]がY個あったとすると答えは XCYになる
- 組み合わせはパスカルの三角形で求める
    - 前計算はO(n^2)
    - アクセスはO(1)
```cs
public static long[,] CombinationTable(int n) {
    var rt = new long[n+1, n+1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            if (j == 0 || i == j) rt[i, j] = 1L;
            else rt[i, j] = (rt[i - 1, j - 1] + rt[i - 1, j]);
        }
    }
    return rt;
}
```

# ABC061 D Score Attack
- 閉路検出が必要だったのでトポロジカルソートかと思ったけど違った
- コストの正負を逆にして最短経路を出す。負数が表れるので使うのはベルマンフォード法
- BellmanFordクラスを作ってループがあるかどうかのプロパティも持たせた
- ベルマンフォードで閉路が見つかったら`inf`、無ければ`-Distance[N-1]`が答え

# ABC070 D Transit Tree Path
- 重み付き木に対して`xi⇒K⇒yi`を通る最短距離の質問に`Q`個答える問題
- 事前に点KからダイクストラしておけばTLEしない
- その後Q個の質問に対して`Distance[xi]+Distance[yi]`を出力すればOK

# ABC073 D joisino's travel
- 訪問しなければならない点を全て訪れたときの最小コストを求める問題
  - 順番は何でもOK
- 制約が小さいのでワーシャルフロイド法＋DFSで解く
- 1次配列で訪れた点を記憶する方法いつも忘れるのでメモ
```cs
//Rは訪れる点の個数
//resはワーシャルフロイドの結果
var used = Enumerable.Repeat(false, R).ToList();

Func<int, int, long, bool> dfs = null;
dfs = (step, before, distance) =>
{
	if (step == R + 1) {
		min = Min(min, distance);
		return true;
	}

	R.REP(i =>
	{
		if (used[i]) return;
		used[i] = true;
		if (before == -1) dfs(step + 1, i, 0);
		else dfs(step + 1, i, distance + res[rList[i]][rList[before]]);
		used[i] = false;
	});
	return true;
};
```

# ABC076 D AtCoder Express
- 与えられたN個条件を満たすような台形の面積を求める問題。
- 各点を記憶していくのは実装がバグるので絶対やめた方がいい
- この問題では時刻Xがすべて整数なので、時刻が0.5の倍数のとき傾きが変化する。
- そのため`時刻a(aは0.5の倍数)`での出せる最大の速度を`v(a)`とすると、`(a(a)+a(a+0.5))/4`の合計が答えになる
- 0.5刻みの配列を表現するために時間を2倍に拡張して1要素が0.5を表すようにする。
```cs
var time = 0;

N.REP(i=>(T[i]*2).REP(k =>
{
	box[time] = Min(box[time], V[i]);
	time++;
	box[time] = Min(box[time], V[i]);
}));
```
- 時刻`time`のときにとりうる最大値を`Min`を使って得る。超えてはいけないのでMin
```cs
for (var i = 1; i < sum; i++) 
    box[i] = Min(box[i], box[i - 1] + 0.5, box[i + 1] + 0.5);
for (var i = sum-1; i >= 1; i--) 
    box[i] = Min(box[i], box[i - 1] + 0.5, box[i + 1] + 0.5);
```
- 次に前後から整合性を取る。
  - 時刻`i`の速度はその前後の`±0.5`かそれ自身であるはずなのでそのうちの最小値が正確な値となる
- あとは和を計算して終わり

# ABC079 D Wall
- 数値`x`を`1`にする問題。`x`から`1`にするには`A[1][x]`のコストがかかる。
- `A[][]`が`10×10`なのでワーシャルフロイドで全点間最小距離を求めて-1,1を省いたあとsumすればおわり
- やるだけって感じだけど有向グラフなので注意

# ABC080 D Recording
- 累積和問題。ばぐらせてつらい
- S+0.5の期間～～みたいなことが書いてあるので取りうる数値を2倍にした配列用意してimosする
- このとき各チャンネルごとにimosすると楽になる
- レコーダーは`S-0.5`から使えなくなるので
```cs
imos[ci-1,si*2-1]++;
imos[ci-1,ti*2]--;
```
- とするとうまくいく
```cs
C.REP(i=>{
    (100005*2).REP(j=>{
        if(j!=0) imos[i,j]+=imos[i,j-1];
        if(imos[i,j]>=1)REC[j]++;
    });
});
REC.Max().WL(); // こたえ
```

# ABC084 D 2017-like Number
- 時間中に解けなくて辛すぎた問題。
- 条件にあう素数リストを事前に求めてimosで数え上げをする。
- `yield return`でエラトステネスの篩を高速化（コピペ）したのでメモ
```cs
public static IEnumerable<int> Primes(int maxnum) {
	yield return 2;
	yield return 3;
	var sieve = new BitArray(maxnum + 1);
	int squareroot = (int)Math.Sqrt(maxnum);
	for (int i = 2; i <= squareroot; i++) {
		if (sieve[i] == false) {
			for (int n = i * 2; n <= maxnum; n += i)
				sieve[n] = true;
		}
		for (var n = i * i + 1; n <= maxnum && n < (i + 1) * (i + 1); n++) {
			if (!sieve[n])
				yield return n;
		}
	}
}
```
- `IEnumerable`で`yield`使うのすっかり忘れてた・・・反省したい
  - これに`Where(x=>IsPrime((x+1)/2))`すれば条件に合う素数リストができる
```cs
public static bool IsPrime(int n) {
	if (n == 2) return true;
	if (n < 2||n%2==0) return false;
	var i = 3;
	int sq = (int)Sqrt(n);
	while (i <= sq) {
		if (n % i == 0) return false;
		i += 2;
	}
	return true;
}
```
- 時間中にバグらせてたのは範囲の指定を`imos[ri+1]-imos[li]`じゃなくて`imos[ri]-imos[li-1]`で計算してたこと
  - imosむずい

# ARC058 D いろはちゃんとマス目 / Iroha and a Grid
- 問題をかみ砕くと升目上を最短経路で移動するとき、`(0,0)=>(H-A-1,i)=>(W-1,H-1)`へ移動するパターンを数え上げる問題になる
  - ただし`B <= i < W`
- これを逆に考えると通ってはいけないルートを通るパターンを全体から引けば良いというのが分かる
- `n×k`マスの升目の最短経路の個数は`(n+k)Ck`で計算できる。
  - これを毎回計算するとTLEするのでテーブルを作る
  - `nCk`は、`(n+k)!/(n!k!)`で求められるのでこれを用意したい。
- パスカルの三角形より大きな数を用意できるけど、小さな値ならあっちのがはやい
```cs
var factorial = new long[100001 * 2];
var inverse = new long[100001 * 2];
factorial[0] = inverse[0] = 1;
for (var i = 1; i <  factorial.Length; i++) {
	factorial[i] = Mod(factorial[i - 1] * i);
	inverse[i] = ModPow(factorial[i], ModValue - 2);
}

Func<int, int, long> Combination = (n, k) =>
{
	if (n - k < 0) return 0;
	var rt = factorial[n];
	rt *= inverse[k];
	rt %= ModValue;
	rt *= inverse[n - k];
	return Mod(rt);
};
```
- これで組み合わせに`O(1)`でアクセスできるのでこれを利用する。
- あとは`A×B`の各点を経由して右下まで移動するパターンを全体から引いていくことでAC

# ARC089 D アンバランス / Unbalanced
- 部分文字列に1つの文字が過半数含まれているかを探す問題
  - 部分点はSの長さが100なので全探索でも間に合う
  - 満点取るには全探索じゃTLE
- ある文字列についてその過半数がアルファベットXであるということは
  - XX
  - XYX(Yは任意)
- のどちらかが含まれていることになる。
  - これらがない場合1種類の文字の間に必ず2文字別の文字が挟まることになる
  - 過半数を超えることはないためアンバランスになりえない
- これをチェックすればいいので`O(|S|)`で解ける

# ARC061 D すぬけ君の塗り絵 / Snuke's Coloring
- H×Wマス内の全ての3×3マスに何個の黒マスがあるかを数え上げる問題。
  - 制約が大きいため全探索は不可能
  - 平面imosっぽいけど全然違った
- あるマス(x,y)が黒であったとき、そのマスを含む9個の3×3マスが存在する。
- この9個のマスが何回出てきたかを記録する。
  - 出てきた回数がその3×3マスに含まれる黒マスの個数になる
  - 0個含まれるのは(H-2)×(W-2)から↑で求めた総数を引くと解る
- こういうX,Yの組み合わせを`Dictionary`の`Key`に使う場合`Tuple<long,long>`を使うとTLEする。（した）
  - これを爆速にするには`long`にしまい込む方法がある。
  - 今回は`ai,bi`ともに10^9なので`pos=ai*1000000000+bi`とすれば一意の組み合わせを`Tuple`とか使わずに表現できる。
    - 10倍ぐらい速度が違う

# ARC065 D 連結 / Connectivity
- 二つのグラフが与えられる。頂点iと頂点jが二つのグラフともに連結かどうかを調べる問題
  - 出力は頂点iに対して頂点jが何個あるかを列挙する。
- 連結かどうかを調べたいので`Union-Find`を使えばここは一撃。
  - 問題は個数の列挙
  - 頂点i,jが二つのグラフでともに連結は、鉄道のUFを`ufK`,道路のUFを`ufL`とすると
    - `ufK.IsSameGroup(i,j) && ufL.IsSameGroup(i,j)`
  - Nが`2×1e5`なのでこれを愚直に全探索は不可能
- ここでUFの特徴を考える
  - それぞれの要素（今回はそれぞれの町）について連結しているグループの親は1つ。（親の親は自信）
  - 各町iについて二つのUFから`親の組み合わせ`が列挙できる。
  - 親の組み合わせがいくつあるかが答えになる。
    - これを各町iについてへ復元しないといけないが解説はここでソートを使うって書いてた（わからん）
  - 組み合わせを数える`Dictionary`と町iがどの組み合わせだったからを記録する配列を用意して町iの情報を`O(N)`で作る。
  - `Dictionary`と配列から情報を復元して`StringJoin(" ")`すればAC

# ARC073 D Simple Knapsack
- 普通のナップザック
- `Dictionary`使う実装の方がREださなくて済む

# ARC074 C Chocolate Bar
- チョコレートに見立てたマス目を3つに分割して最小の面積と最大の面積の差のMinを探す問題
  - C問題のくせに400点という暴力
- 分割の方法は`T`か`≡`か`川`か`ト`の4パターンしかない。なのでこれについてそれぞれ`O(H)`で計算する。
  - このうち`T`と`≡`は向きを変えれば残りの二つのパターンになる。
    - つまりこの二つを計算する関数を作って引数のタテヨコを入れ替えるだけでOK
  - さらに`T`と`≡`は同じループ内で計算できる。
    - 上の横長の領域の高さについて`O(H)`でループする。
    - 面積の計算は`O(1)`
- ようはこんな感じ
```cs
Func<long, long, long> getMinimumDivide = (h, w) => {
	var min = long.MaxValue;
	new Tuple<long, long>(1, h).FOR(ah => {
		//≡
		{
			var bh = (h - ah) / 2;
			var ch = h - (ah + bh);
			min = Min(min, Max(ah * w, bh * w, ch * w) - Min(ah * w, bh * w, ch * w));
		}
		//T
		{
			var bw = w / 2;
			var cw = w - bw;
			var bch = h - ah;
			min = Min(min, Max(bch * bw, bch * cw, ah * w) - Min(bch * bw, bch * cw, ah * w));
		}
	});

	return min;
};
```

# ARC075 D Widespread
- 1体にAダメ、ほかにBダメ与える攻撃を使ってN体の敵を倒すとき、必要な最小の攻撃回数を求める問題
  - Nが10^5なのでimosか二分探索かソートかって感じだとおもった
- 問題を読みかえると`T`回攻撃するとき、それぞれの敵に対して`B×T`ダメージと、任意の敵に`(A-B)×T`ダメージを与えることになることが分かる
  - `T`回の攻撃ですべての敵を倒せるかのチェックは`O(N)`でできる
```cs
Func<long, bool> check = (T) => {
	var at = T;
	foreach (var item in H) {
		var hitpoint = item - B * T;
		if (hitpoint <= 0) continue;
		var req = (int) Ceiling(((double) hitpoint / (A - B)));
		if (req <= at) at -= req;
		else {
			return false;
		}
	}
	return true;
};
```
- この`T`の求め方は二分探索で求める。範囲は`0~H.Max()/B`
  - 計算量は`O(logH.Max()/B)`
- 合わせると`O(N×logH.Max()/B)`なので間に合う

# ARC078 D Fennec VS Snuke
- 木の中で陣取りゲームをする。先にとれなくなった方の負け
- フェネックとすぬけ君がとる最善の行動は先に行けるところまでお互いに近づく行動
  - 相手の行動を1つつぶせるから
  - 進行方向以外の向きに向いてる枝とかはぶつかった後でとれるので後回しでいい
- それを踏まえて考えると各`Node`にたいしてそれぞれのスタート地点からの距離が短い方がそのマスを獲得することができるとわかる。
  - DFSかBFSで0とN-1から各`Node`が何ステップ目にあるかを記録し`d[0,i]<=d[N-1,i]`ならフェネックのマス、そうじゃないならすぬけ君のマスになる
- これを数え上げて比較すればAC
  - たぶんコスト1の辺とみてダイクストラしても行けると思うけどDFSのがかんたん

# ARC080 C 4-adjacent
- 数列を並び替えて隣同士の積がすべて4の倍数になるかを調べる問題
- この数列内には3つの要素がある
  1. 4の倍数
  2. 4の倍数じゃないけど2の倍数
  3. 奇数
- 並び替え方は1の数字とそれ以外が交互に来る並び替え方だとわかる。 
- しかしこのとき2の個数が問題に大きくかかわってくる
  - 2の数字はそれ単体では奇数と同じ役割だが偶数個ずつ集まると4の倍数になれる
  - この問題の場合並び替えるときに2の数字は端っこに追いやればいいので考えないといけないのは追いやったところとガチで並び替えたところの境目
  - この接合部では2の数字と1の数字が隣り合っていないといけない。（奇数と2の数字をかけても4の倍数にはならない）
    - こういう1と3の数字の並べ方は1の個数が3以上じゃないとできない
  - しかし2の数字が1つもないなら、端っこが4の倍数でなくてもいい。
    - こういう並べ方は1の個数が3の個数より1少なくてもいい
- つまり
  - 2の個数が0なら
    - 1の個数+1>=3の個数
  - 1個でもあるなら
    - 1の個数>=3の個数
- がこたえ

# ARC082 D Derangement
- `i==list[i]`となってる部分をXとする
  - 隣り合ったXXは互いに入れ替えればクリア
  - なのでこれを先に処理する
- 次に左と交換できるか右と交換できるかを繰り返してAC

# ARC081 D Coloring Dominoes
- `|`か`=`の形に並んでいるドミノを同じ色が接しないように3色で塗るパターンはいくつあるかを求める問題
- 先頭の組を除いて1つの組を塗る方法は1つか2つか3つしかない。
- 今塗るドミノが`|`のとき
  - 1つ前のドミノが`|`のときはその色以外が使えるので __2通り__
  - 1つ前のドミノが`=`のときは二つの色以外なので __1通り__
- 今塗るドミノが`=`のとき
  - 1つ前のドミノが`|`のときその色以外の上下入れ替えで __2通り__
  - 1つ前のドミノが`=`のときその色の上下入れ替えと片方を含むパターンで __3通り__
- これが解れば先頭からModを取って計算するだけ

# ARC090 D People on a Line
- 重み付き有向グラフに矛盾がないかどうかを調べる問題。グラフがすべて連結とは限らない
  - 解説にはDFSでACと書いてあるけど自分はDFS苦手なので解らない
- 辺の重みもいっしょに管理するUnionFindで解けるらしい
  - [重みつきUnion-Find木とそれが使える問題のまとめ、および牛ゲーについて](http://drken1215.hatenablog.com/entry/2018/02/01/134441)
  - 重み付きUFとかポテンシャルつきUFとか言うらしい。ちゃんとした名前がない
- 重み付きUFは普通のUFに親との重みの差分を持つ
  - 親の重みは0
- 親の重みは必ず0であるので矛盾がない場合は
  - `Parent[i]==i && Cost[i] == 0`
- が必ず成り立つはず
- 重み付きUFに辺を追加していき最後にこれをチェックすればAC

# AGC002 B Box and Ball
- N個の箱があり、箱[xi]から玉を一つ箱[yi]へ移動させることをM回行って、赤い玉が入ってる可能性のある箱の個数を求める問題
  - 可能性を考えるので赤い玉を積極的に動かしていくのがいい
- まず赤玉が入ってるかもしれないを表す`bool box[N]`と箱に何個玉が入ってるかを表す`int count[N]`を用意する
  - 各操作では毎回`count[xi]--`と`count[yi]++`（玉の移動）がある
- 箱[xi]から箱[yi]へ玉を移動させるとき
  - `count[xi]`が1で`box[xi]`が`true`のとき
    - 動かした玉は赤玉なので`box[xi]`に赤玉は存在しない⇒`false`にする
    - 動かした先の箱[yi]に赤玉が移動するので`box[yi]=true`
  - `count[xi]`が1より多く、`box[xi]`が`true`のとき
    - 動かした玉が赤玉 __かもしれない__ ので`box[yi]=true`
    - しかし動かした玉が赤玉 __じゃないかもしれない__ ので`box[xi]=true`のまま
- こうやって求めた`box`が赤玉が入ってるかもしれない（＝可能性）リストにになるので`true`を数え上げればOK

# AGC003 B Simplified mahjong
- 数値iが書かれたカードがx[i]枚あり、数値の差の絶対値が1ならペアにできるとき、できるペアの最大値を求める問題
  - 重要なのはx[i]が偶数か奇数か
- x[i]が偶数のとき
  - 数値iだけで完結するのでノータッチ
- x[i]が奇数のとき
  - 隣り合うi+1かi-1から1枚借りてくることでペアを最大化できる。
    - プロフラム的に前から見ていくので今回はi+1から借りることにする
  - x[i+1]が1枚以上あるときx[i]を偶数にできる（1枚もないならできない）
    - x[i+1]が奇数になる場合もあるがx[i+2]から借りてくる前提
    - x[i+2]が0の場合もあるが、これはx[i]がx[i+1]から借りてこようが結果は一緒になる
      - `1,4,0` ⇒ `2,3,0`と`1,4,0`にできるがペアは2個しかできない
      - `1,4,3` ⇒ そのままだと3ペア。`2,4,2`にすれば4ペア
  - こうやってできるだけ要素を偶数化した配列を用意し、`box.Select(x=>(long)x/2).Sum()`すれば答え
    - オーバーフローするので注意

# AGC004 B Colorful Slimes
- スライムiを作るのに何かを進化させてくるか、素で捕まえるかを選んで最小のコストを探す
- iを手に入れるのに進化をk回するとすると、手に入れるには`min(ai,ai-1,...ai-k)`になります
- これを用いてkを0~N-1の範囲で計算する
  - 計算式は`k×x+Sum(min)`
  - これの最小値が答えになる。`O(N^2)`

# AGC005 B Minimum Sum
- 200,000要素の区間`[l,r](lは1~N,rはl~N)`の最小値の合計を取る問題
  - やはり400点問題には難易度差があるなと感じた1問
- `set`を使う解法は解説を読んだり解説の解説を読んでも解らなかったのでUnionFindを使うやつを採用
  - [AtCoder Grand Contest 005: B. Minimum Sum - pekempeyのブログ](http://pekempey.hatenablog.com/entry/2016/10/02/042213)
- 区間の最小値がvになる区間がいくつあるかを数え上げることを考える
- vの左右の要素がvより大きかったら`Unite`する（同グループになる）
  - このとき連結された方に連結した方の左右につながっているノードの数を加算する（＝サイズ）
  - ノードが持っているサイズがその値が最小値になる区間の数なので、値と区間の数を乗算する
    - これの和が答え
- UFは大きい方からUniteする。
```cs
public void Solve() {
	var N = NextInt();
	long[] a=new long[N],aindex=new long[N];
	N.REP(i =>
	{
		a[i] = NextLong();
		aindex[a[i]-1] = i;
	});

	var suf = new SectionUnionFind(N);

	var ans = 0L;
	for(var k = N-1; k >= 0; k--) { 
		var i = (int)aindex[k];
		ans += a[i];
		if (i - 1 >= 0 && a[i - 1] > a[i]) ans += suf.Unite(i - 1, i) * a[i];
		if (i + 1 < N && a[i + 1] > a[i]) ans += suf.Unite(i + 1, i) * a[i];
	}
	ans.WL();
}
public struct SectionUnionFind
{
	private readonly int N;
	public int[] Parent { get; private set; }
	public long[] Cost { get; private set; }

	public SectionUnionFind(int n) {
		N = n;
		Parent = Enumerable.Range(0, N).ToArray();
		Cost = Enumerable.Repeat(1L, N).ToArray();
	}

	public int Root(int x) {
		return Parent[x] == x ? x : Parent[x] = Root(Parent[x]);
	}

	public long Unite(int x, int y) {
		x = Root(x);
		y = Root(y);
		var res = Cost[x] * Cost[y];
		Cost[x] += Cost[y];
		Parent[y] = x;
		return res;
	}
}
```

# AGC006 B Median Pyramid Easy
- あるマスの真下、右下、左下の中央値をそのマスに書いていくピラミッドで、頂点がXだったとき、N段目はどういう数列かを求める問題
  - ただし数列は`1~2N-1`の重複の無いもの
- Xが1か2N-1のとき不可能
  - 1は最小値、2N-1は最大値なので中央値になりえない
  - しかしそれ以外は可能
- N=2のとき
  - Xが2なら`{1,2,3}`が答え。それ以外は↑の例外にひっかかる
- N>2のとき、2段目の3マスのうち2マスがXなら頂点をXにできる
  - これを目指す
- N-1段目の中央とその隣（左右どちらでもいい）がXであったとき、その上のN-2段目も中央とその隣のマスはXになる。
  - N-3段目以降も同じ
- つまりN-1段目の中央とその隣のマスにXが来るような数列を考えればいいので
  - xは2N-2までの値をとるので `{...,x-1,x,x+1,x-2,...}` みたいな数列がある
  - ただしx=2のときは使えないので `{...,x+1,x,x-1,x+2,...}` に変えるといい
- あとはこれを出力すればAC

# AGC007 B Construct Sequences
- 昇順に並んだ数列Aと降順に並んだ数列Bがある。数列`P={p1,p2,...,pN}`に対して`A[p1]+B[p1] < A[p2]+B[p2] < ... < A[pN]+B[pN]`を満たすA,Bを求める問題
  - imosみたいな差分を取る方法を試したけど整合性をとれなかった
- 数列Cを`C={A[1]+B[1],A[2]+B[2],...,A[N]+B[N]}`とする。
  - このCが昇順に並んでればいい
  - 一番簡単なのは`{1,2,3,...}`だがA,Bも負数はありえないのでこれはできない
  - これをある程度シフトアップすることを考える。例えば `{401,402,403,...,400+N}` みたいなやつ。これなら作れそう
  - これをCのルールにする
- Cのルールを守りながらAとBの公差を固定化する。
- A,Bどちらかの数列は単純な倍数でいい。
  - `A={400,800,1200,...,400N}`とか
  - このときBも `{400N,400(N-1),...,400}`とするとCのルールが守られない
  - しかしCは全て同じ値になる
- なのでBの下の桁にPに出現した順番を記録する
  - 数列Rを`R[pi]=i`としたとき
  - Bを`B={400N+R[i],400(N-1)+R[i+1],...,400+R[N]}`とすれば、Cのルールを守る数列A,Bができる
- この400はどうやって求めるかというと適当な大きな数値でいい（解説だと30000だった）

# AGC008 B Contiguous Repainting
- AGCむずすぎる
- 連続するKマスを黒か白に塗る。最終的に黒だったマスに塗られている値が得点になり、その最大値を求める問題
- 最初にある区間を塗る。すると他のマスは自由に色塗りができる（1マスずらすだけでいい）
- これを利用してimosで解く
- imosは二種類確保する
  - そのままのimos
  - 正数だけのimos
- そのあとi(K<=i<=N)について
  - `ans = Utils.Utils.Max(ans, imosB[N] - (imosB[i] - imosB[i - K]) + (imosA[i] - imosA[i - K]),imosB[N] - (imosB[i] - imosB[i - K]));`
- を計算してAC

# AGC011 B Colorful Creatures
- 色iと大きさAiを持つモンスターがN体いる。大きさXiが2Yi以下なら大きさYiを持つモンスターを吸収し、色iのまま大きさがXi+Yiになる。最後の一体になったとき色の可能性としてあり得るのは何色か
  - PriorityQueueで小さい順に吸収させていって色を最大化するのかと思ったけど違った
- 先ずは大きさでソートする。
- 次に`2sum(k) < A[k+1]`となるようなkの最大値を探す。これをtとする。ない場合は0
  - このとき`{1,2,3,....t}`番目のモンスターの色が残るためには`t+1`番目を吸収しないといけない
  - しかし`{1,2,3,....t}`番目を合計してもそれはむりなのでここまでの色はなくなる
- 色の最大値はNであるのでこのtを引いた`N-t`が答え

# AGC015 B Evilator
- 各階には上に行くか下に行くかしか書いてないエレベータが設置されてる。全ての階からすべての階に行くのに必要なエレベータに乗る回数は何回か求める問題
  - エレベータを作ったやつは無能
- i階からj階に行くのにエレベータに乗る回数は1回か2回
  - i階に書いてあるボタンが`U`のとき
    - 下へ行くには2回乗る
    - 上に行くには1回乗る
  - i階に書いてあるボタンが`D`のときはその逆である
  - これらの計算は`O(1)`でできる
- これの合計が答え
```cs
S.ForeachWith((i, c) =>
{
	if (c=='U') {
		//下へ行くには2回乗る
		cnt += (i) * 2;
		//上に行くには1回乗る
		cnt += N - i - 1;
	}
	else {
		//下へ行くには1回乗る
		cnt += i;
		//上に行くには2回乗る
		cnt += (N - i-1) * 2;
	}
});
```

# AGC017 B Moderate Differences
- N個のマス目の端っこに数値AとBが書いてある。隣り合う数値の差はC以上D以下であるように書くとき、N個のマス全てを埋めれるかを求める問題
  - こういう数学の証明みたいな問題は本当に苦手だ・・・
- iマス目に書く正数を`X[i]`、`Y[i]=X[i+1]-X[i]`とする。
  - さらに`sum(Y) = sum(X[i+1]-X[i]) = X[N]-X[1] = B-A`
- 隣接するマスの条件は`-D <= Y[i] <= -C or C <= Y[i] <= D`
  - これを満たす`{Y}`があるときは`{X}`も存在する
- ここで`-D <= Y[i] <= -C`を満たす`i`が`m`個あるとする。
  - 他の`N-1-m`個は`C <= Y[i] <= D`が成り立つ
- 条件式をiについて足し合わせると
  - `C(N-1-m)-Dm <= sum(Y) <= -Cm+(N-1-m)D`
  - この計算は`O(1)`
- これを満たす`m`を探せばOK
  - `m`は0からN-1の範囲を探せばいいので全体で`O(N)`
- こういう`m`みたいな何かを固定して計算式をおったてるやり方はマスターしたい
- ちなみにこういうのはLINQだと得意
```cs
(Enumerable.Range(0, (int) N - 1)
	.Select(m =>  new {under = C * (N - 1 - m) - D * m, top = -C * m + (N - 1 - m) * D} )
	.Any(item => item.under <= B - A && B - A <= item.top)?"YES":"NO").WL();
```

# CODE FESTIVAL 2016 Final: C Interpretation
- N人の人間がそれぞれK[N]個の言語を話せる。誰かを介すか本人同士で意思疎通ができるか確かめる問題
  - めっちゃUnion-Findっぽい
- Union-Findだった
- 満点をとるには人と言語でN+M辺の2部グラフを考える。人同士が連結ならOK
- これを調べるにはUnion-Findが簡単
- Union-Findの要素数はN+M個。
  - これにどんどんUniteしていく

```cs
N.REP(i => { 
    GetIntList()
    .Skip(1)
    .ToList()
    .ForEach(Li => uf.Unite(Li - 1 + N, i));  //Li - 1 + Nが言語、iが人の頂点
});
//連結しているかをチェック
(Enumerable.Range(0,N).All(i => uf.IsSameGroup(0,i))?"YES":"NO").WL(); 
```

- Union-Findやるだけの問題だった

# CODE FESTIVAL 2016 qual A C 次のアルファベット / Next Letter
- 文字列Sに対して1文字選んで次のアルファベットにすることをK回繰り返す。作ることのできる文字列のうち辞書順で最初のは何か
  - zの次はa
  - やるだけ
- 前から順番にK回以内にaにできるかを試す
  - aにできるならKの回数を消費してaにする
  - できないなら次に持ち越す（中途半端にずらすと辞書順で遅くなる）
  - 余った数値は最後尾の文字で消費する。このとき26のあまりで計算しないとWAになる

# CODE FESTIVAL 2016 予選 C 二人のアルピニスト / Two Alpinists
- 二つの数列TとAはそれぞれ前からと後ろからの最大値を記録している。ありうる数列は何パターンあるか求める問題
  - 普通にMinとって掛け算するだけだと思ったら違った
- 求めたい数列をHとする
- Tについて見てみる
  - `T[i-1]<T[i]`のとき`H[i]=T[i]`である
  - それ以外の場合は`H[i]<=T[i]`になる。つまりここで`T[i]`通り増える
- Kについて見る
  - `A[i]>A[i+1]`のとき`H[i]=A[i]`になる
  - それ以外は`H[i]<=A[i]`になる
- TとAそれぞれについて一つ前と比べて増えているか減っているかを`bool`で持つ
  - これをudTとudAとする
  - udT[0]とudA[N-1]はtrue
- 順番に整合性が取れているかを見ていく
  - `udT[i] && udA[i]`のとき
    - このときTとAで最大値が更新されている
    - なのでパターンは1通り
    - しかし整合性を取るには`T[i]=A[i]`が成立していないとダメ
      - 最大値が更新されているので値は一緒になるはず
  - `udT[i] && !udA[i]`のとき
    - このときはTで最大値が更新されていて、Aではされていない
    - なのでパターンは1通り
    - 整合性を取るには`T[i]<=A[i]`が成立していないとダメ
      - Tは更新されたのにAが更新されないということはAの方が大きいということ
  - `!udT[i] && udA[i]`のとき
    - このときはAが最大化されていて、Tではされていない
    - なのでパターンは1通り
    - 整合性を取るには`A[i]<=T[i]`が成立していないとダメ
      - Aは更新されたのにTが更新されないということはTの方が大きいということ
  - `!udT[i] && !udA[i]`のとき
    - どちらも最大値が更新されなかった
    - このときは`Min(A[i],T[i])`パターンある
    - 整合性をチェックする必要はない
- こうやって作り出したパターンをかけ合わせていくと答えになる。modは忘れるなよ

# CODE FESTIVAL 2017 Final: B Palindrome-phobia
- a,b,cの三文字からなる文字列Sを並べ替えて2文字以上の部分文字列に回文ができないようにできるかを求める問題
  - B問題なのに400点か・・・・・・
  - やるだけだった
- 回文にならないような並べ方の1つに`abcabcabc.....`と並べる方法がある
- これを目指すことを考える
- まずa,b,cがそれぞれ何個あるかを数え上げる
- そこからabcの組み合わせの最大個作る
  - a,b,cの最小個数がそれ
- のこったa,b,cを見る
  - たとえばa,b,cのどれかが1つ残った場合
    - `...abc[a] or [c]abc... or ...bca[b]`にすればOKとなる
  - もしくはa,b,cのうちどれか2つが残った場合
    - `...abc[ab] or ...bac[ba] or ...acb[ac]`に並び替えられる
  - 実はa,b,cどれかのうち1つでも2個以上残っていたら成立しない
    - 例えばaが2つ残ったとき、完成している文字列をaで挟む感じになる
      - `abc,bca,cab,bac,cba,acb`の連続が考えられるがいずれを挟んでも回文ができないようにならない
      - ほかのも同様
    - a,a,cが残った場合でも同様に挟み込んだりしても不可能
- なのでこれを`O(|S|)`で数え上げてそれぞれをチェック。条件を満たしていなければ"NO"になる

# CODE FESTIVAL 2017 qual A C Palindromic Matrix
- 行列Aの要素を自由に並べ替えてどの行、列に対しても回文になっているかを確かめる問題
  - 誤読してて死んだ
- まずは行列を分解して文字を数え上げる
- 数え上げた辞書に対して`item.Value%=4`とした辞書を`map`とする
- HとWが偶数のとき
  - 各文字が4つずつあればOK
- HとWが奇数のとき
  - ど真ん中にある1つは何でもいい。
  - map[3]が1つでもあるとダメ
  - map[1]が1つだけあるとOK
  - map[2]は全体で最大でも`(H-1)/2+(W-1)/2`個使われるのでそれ以下であればOK
- HかWが偶数のとき
  - Wが偶数だとすると
  - 中心の行は横向きの回文にしか影響しない（縦の回文では中心になるので）
    - そこを除けばどちらも偶数の場合一緒
  - この中心はmap[2]がW/2個以下ならOK（足りなくてもmap[0]を崩せばいい）

# CODE FESTIVAL 2017 qual C C Inserting 'x'
- 文字列の任意の場所にxを挿入して回文ができるかを求める問題
- 回文なので文字列を両端から比較していく
  - s=0,e=S.Length-1から始まるとする
- S[s]==S[e]のとき
  - 回文の条件を満たしているのでOK。sとeを内側へすすめる
- S[s]='x' || S[e]='x'のとき
  - どちらかが'x'なので反対側に'x'を挿入すればバランスが取れる
- S[s]!=S[e]のとき
  - ダメ
- やるだけという感じだけど真ん中の場合でバグらせて辛かった

# CODE THANKS FESTIVAL 2017: E Coin Authentication
- N個の袋それぞれに10000枚のコインが入っている。10回の計測でそれぞれがどの重さのコインかを求める問題
  - Nは50まで
- インタラクティブな問題ということでQueryの作成とそのResponseをパースする必要がある
  - あとAutoFlushもOnにしないとだめ
- Nが50だが10回しか質問できないため1回の質問で5回は判別しないといけない
  - ここで1袋10000枚入っているのがポイントになる
  - 質問を`{...,1,10,100,1000,10000,...}`というふうに構成していく
  - こうすることで5つの別々の質問を1度に行える
  - 例えばResponseが`92300`だった時
      - 1の位が0なので1枚で質問した袋は重さが`10`だと解る
    - これを取り除いて10で割ると次は`9229`になる
      - これは1の位が9なので10枚で質問した袋は重さが`9`だと解る
    - 同じように次は`922`になる
      - 1の位が2なので100枚で質問した袋は重さが12になる
    - 次は`91`になる
      - 1の位が1なので1000枚で質問した袋は重さが11になる
    - 最後に`8`になる
      - 10000枚で質問した袋は重さが`8`になる
    - つまり質問`{...,1,10,100,1000,10000,...}`の答えは`{...,10,9,12,11,8,...}`にパースできる
  - これを5つずつ順番に質問していくことでコインの重さがすべてわかる
- 面白かった

# COLOCON -Colopl programming contest 2018- 予選: C - すぬけそだて――ごはん――
- 区間`[A,B]`でに互いに素な数値の組み合わせは何個あるかを求める問題
  - タイトルがなげえ
- B-Aが35という制約があるので全探索できそうだけどその方法が思いつかなかったので解説見たら全探索でACとだけ書いてあった
  - 他の人の提出をみたらbitDPを見つけたので真似した
- 先ずは35までの素数をリストアップする
  - 2,3,7,9,11,13,17,19,23,29,31 の11個
- bitDPするので`var bitdp=new long[1<<11]`を用意
- どれも選ばないパターンである`bitdp[0]=1`が初期値
- AからBまでforを回す
  - `A<=x<=B`とする
  - 今見ている`x`についての`bit`を作る
    - xと素数リストと順番に剰余を取る。余りが0だったときは`bit`を立てる。`if(x%prime[i]==0)bit |= 1<<i;`
    - これでどんな素数でxが構成されてるかわかる
  - 結果を記録する配列を用意する。`nextdp`とする
    - まずは`nextdp[i]+=bitdp[i]`
    - 次にiがbitと互いに素かチェックする。これにはbit同士のANDを計算したとき、結果が0なら互いに素であるのでこれをみる
    - もし互いに素なら今度はbitごとにORをとってパターンを計算する。そこにも`bitdp[i]`を加算する
      - `if(i&bit==0) nextdp[i|bit]+=bitdp[i]`
  - 最後にbitdpをnextdpで更新してループが終わり
- 最後まで計算した後bitdpに各パターンの個数が入っているのでsumしてAC
- bitdp始めてやった

# DISCO presents ディスカバリーチャンネル コードコンテスト2016 予選: C - ロト2
- 数列Aがある。任意の(i,j)に対してA[i]×A[j]がKの倍数となる(i,j)はいくつあるかを求める問題
  - 全然わからんかった
- Nが200,000なので全探索をするのは不可能
- 問題を読み替えてGCD(A[i],K)×GCD(A[j],K)がKの倍数になるかという問題にする
- Kの約数は1,344個程度らしいのでGCD(A[i],K)の分布をDictionaryで調べてやれば`O(1,344^2)`で計算できるらしい
- 前準備
  - `list=dic.Select(item=>new Tuple<long,int>(item.Key,item.Value)).ToList()`
  - `M=list.Count`
- 2重forを`i(0<=i<M),j(i<=j<M)`でする
  - `list[i].Item2*list[j].Item2%K==0`のやつが目的のやつ
  - ここでi==jのとき
    - list[i]を2つ使うことになるので`list[i].Item2*(list[i].Item2-1)`さらに(i,j)と(j,i)は同じものなのでこれの半分
  - i!=jのとき
    - 普通に`list[i].Item2*list[j].Item2`個
- むずかしいすぎる

# SoundHound Inc. Programming Contest 2018 (春): C - 検索
- 40×40マス目の`.`の位置に最大で何個の広告を置くことができるかを求める問題
  - 置いたところの上下左右にはおけなくなる
- 初めて二部マッチングの問題に出会った。
- こういうマス目になっているグラフをグリッドグラフというらしい
  - さらに4近傍に辺をはるグリッドグラフは二部グラフであるらしい
- この問題ではこのグラフの最大独立集合のサイズを求めればいい
  - 最大独立集合は頂点集合の部分集合で、各頂点間に辺が存在しないもののうち最大のもののこと
  - なるほど問題で欲しい答えそのままだ
- 二部グラフにおいて最大独立集合のサイズは`頂点数-最大マッチングのサイズ`で求まることが知られている
  - しらなかった
- さらに二部グラフの最大マッチングは最大流で求められるらしい
  - しらなかった
- つまり __二部グラフを構築した後`Dinic法`を使って最大流を調べる。__ と答えが出る
  - むっず
- __二部グラフの辺のはりかた__
  - この問題では4近傍全てに辺を貼ればいいわけじゃない
    - もとから置けないところがある
  - さらに偶数番目はグラフ外の頂点`s`とその4近傍、奇数番目は頂点`t`と辺を貼る必要がある
    - 最大流計算のため
    - 奇数偶数は逆でもいい
  - 偶数番目が4近傍と辺を張るときそこに広告が置けないとダメ。
    - 広告のおける頂点の中で最大独立集合を求めたいので
  - これでこの問題に沿う二部グラフができる

# みんなのプロコン 予選: C 検索
- N個の文字列から指定されたK個文字列だけが一致するような文字列は存在するかを判定する問題
  - 一致は文字列の先頭を見る
  - 存在する場合は最短のもの。しない場合は-1
  - TLEギリギリだったけどACした
- 前準備としてN個の文字列のリストをソートする　⇒ `list`。
- K個の文字列もソートする ⇒ `request`
- まず`N==K`のとき
  - このとき全てをマッチさせたい
  - 全てにマッチする最短の文字列は空文字なので出力する
- K個の文字列の先頭が一致するような文字列というのは`request`が`list`に現れないといけない
  - 間に何か挟まっていたり、抜けていたりすると一致するような文字列は存在しない
    - `request[K-1]の位置 - request[0] + 1`が`K`じゃないときは存在しない
      - この場合は-1を出力
    - 逆にこれが成立するなら __この部分を含めた部分集合を__ マッチする文字列は存在する
- このまま`request[0]`と`request[K-1]`の最短一致を出力すると`list`内で`request[0]`より前、もしくは`request[K-1]`より後ろの文字列にもマッチしてしまう可能性がある
- これを`request`だけにマッチするような文字列を求めるために4つの文字列を見る
  - `min = reqest[0]`
  - `max = reqest[K-1]`
  - `left = list[request[0]の位置-1] 無ければ"1"`
  - `right = list[request[K-1]の位置+1] 無ければ"1"`
  - 無ければというのはダミーの文字列
- マッチする文字列は`min.Length`以下の長さであるのでこれについてforを回す
```cs
var match = "";

var left = minIdx == 0 ? "1" : list[minIdx - 1];
var right = maxIdx == N - 1 ? "1" : list[maxIdx + 1];
var min = request[0];
var max = request[K - 1];

bool lres = true, rres = true, maxres = true;

for (int i = 0; i < min.Length; i++) {
	match += min[i];
	lres &= i < left.Length && left[i] == min[i];
	rres &= i < right.Length && right[i] == min[i];
	maxres &= i < max.Length && max[i] == min[i];

	if (lres || rres || !maxres) continue;
	match.WL();
	return;
}
```
- `min`と`max`がマッチしつつ`left`と`right`がマッチしない`i`を探す
  - 文字列の長さが`i`以下のとき明らかにマッチしないので`false`
  - i番目の文字が`min[i]`とマッチしないなら`false`
  - 条件がそろったときに文字列を出力しておわり
  - 全部試してダメなら-1を出力して終わり
- 割とギリギリだった

# みんなのプロコン 本選 (オープンコンテスト): A YahooYahooYahoo
- こういうコンテストの配点はあてにならない
- 入力文字列Sが"Yahoo"の繰り返しになる編集距離を求める問題
  - レーベンシュタイン距離やるだけかと思ったら違い過ぎた
- `dp[i,j]=S[1..i]をYahooYahoo....Yah[j]にできる最小操作回数`
- この問題ではdpを更新するときに使う値が`y => a => h => o => o => y =>...`となる
- 単純にこれで値を更新すればいいのだけどこのときループを2回しないと"yahyahoo"みたいなパターンでWAが出るらしい
  - わからん

# 天下一プログラマーコンテスト2016予選B: B 天下一魔力発電
- `(`と`)`からなる文字列を変更して対応の取れた文字列にできる最短の操作回数を求める問題
  - 操作は一文字左右に動くことで1回。文字を変更することで1回。
  - `|S|`が100だったのでdpっぽい
- dpだった
- `dp[i,j,k]=i文字目までで最後にj文字目を変更して(と)の差がkの最小値`と定義する
  - S[i]が`(`のとき
    - `dp[i+1,j,k+1] = Min(dp[i+1,j,k+1],dp[i,j,k])`
      - 無操作で差が1つ大きくなるのでこう
    - `dp[i+1,i,k-1] = Min(dp[i+1,i,k-1],dp[i,j,k]+1)`
      - `(`を`)`に変更して差を縮める
  - S[i]が`)`のとき
    - `dp[i+1,i,k+1] = Min(dp[i+1,i,k+1],dp[i,j,k]+1)`
      - `)`を`(`に変えて差を増やす
    - `dp[i+1,j,k-1] = Min(dp[i+1,j,k-1],dp[i,j,k])`
      -無変更で差が1つ小さくなるのでこう
- これで __文字の変更について__ の最小値が求まる。
  - ここでカーソルの移動回数についての回数が必要なのだがこれはd[i,j,k]のjにあたる
    - 左に移動するすることは無駄な手であるため
- 結局
  - `dp[|S|,j,0]+j`
    - (|S|文字目までで最後にj文字目を変更して差が0にカーソル移動の回数を足した数)
- の最小値が答え

# ABC088 D Grid Repainting
- 迷路を進むとき最短経路以外の通れる道は何個あるかを求める問題
- 最短経路を求めるbfsを書いて`.`の総数から最短経路を引くだけ
  - やるだけ！（実装早くしたい）
- 迷路の最短経路すぐ忘れるのでメモる
```cs
var queue = new Queue<ti3>();
queue.Enqueue(new ti3(0, 0, 1));
used[0, 0] = true;
var min = int.MaxValue;
while (queue.Any()) {
	var src = queue.Dequeue();
	for (int i = 0; i < 4; i++) {
		var x = dx[i] + src.Item1;
		var y = dy[i] + src.Item2;
		if (!Utils.Utils.Within(x, y, W, H)) continue;
		if (G[y][x] == '#') continue;
		if (used[y, x]) continue;

		if (x == W - 1 && y == H - 1) {
			min = Min(min, src.Item3 + 1);
			continue;
		}

		used[y, x] = true;
		queue.Enqueue(new ti3(x, y, src.Item3 + 1));
	}
}
```

# 第3回 ドワンゴからの挑戦状 予選: C スキーリフトの相乗り
- 4人乗りのスキーのリフトにグループを壊さずに乗せるとき最低何台の搬器があればいいかを求める問題
  - 400は絶対嘘
- 何人のグループが何個あるかをまずは数え上げる
- 4人グループはそのまま搬器の数に必要
- 1人グループと3人グループは1つに纏められるので`Min(dic[1],dic[3])`ペアできる
  - これを搬器の数に加える
  - このとき3人グループが余ればそのまま搬器の数にする
- 2人グループの半分の数がペアにできるので`dic[2]/2`
- 2人グループが余れば1人グループから人を持ってくる
  - 持ってくる人数は最大でも2人
  - `dic[1]=Max(dic[1]-2,0)`
- 1人グループを纏める
- 4人ずつに区切って搬器の数に加えて出力
- `O(1)`

# ABC047 D 高橋君と見えざる手 / An Invisible Hand
- 高橋君はA[i]でリンゴをかってA[j]で売るとA[j]-A[i]円儲かる。青木君はこれをコストをできるだけ少なくしつつ高橋君の収益を減らしたい。
- 青木君がA[i]をXに変えるとき|A[i]-X|のコストがかかる。このときの最小コストはいくらか
  - 高橋君の行動を青木君が邪魔する系問題
- 1円でも少なくすればいいので`A[j]-A[i]`を1減らすことを考えると`A[i]++`かA[j]--`が考えられる。
  - これのコストは1。
- 高橋君の戦略的にA[j]-A[i]が一番高いところで売り買いするのが最良手。これを青木君は邪魔すればいいのでコスト1でこれを邪魔する。
  - ところがA[j]-A[i]が同じ値になったときにこの操作が互いに影響するのではないかと思われる
  - ここでA[i]はすべて違うというところが重要になる。
    - A[i]がすべて違うということは差が同じ値になる組の値もそれぞれ違う
    - よって操作はお互いに干渉しない
- なのでA[j]-A[i]の最大値が何個あるかを求めればOK。`O(N)`

# ARC087 D FTRobot
- 500点問題
- 文字列が与えられる。Fのときは前進、Tのときは右か左に90度回る。XとYが与えられるのでそこにたどり着くことができるかという問題
  - DP
- 文字列をTで分割する。Fが連続する部分は1つにまとめる続く分だけ進むと読み替えられるので分割した長さのInt配列にする
- これの偶数番目はX軸方向、奇数番目はY軸方向に進む命令になる
- XとYそれぞれについてDPする。setを使うと楽に実装できる
  - ただしXについては最初は前進しかできない（後退できない）のでXの初期位置はxl[0]
```cs
Func<int, Li, bool> dp = (goal, list) =>
{
	var set = new HashSet<int>() {list[0]};
	list.RemoveAt(0);
	var N = list.Count;
	N.REP(i =>
	{
		var next = new HashSet<int>();
		foreach (var item in set) {
			next.Add(item + list[i]);
			next.Add(item - list[i]);
		}

		set = next;
	});
	return set.Contains(goal);

};
```

# ARC060 D 桁和/Digit Sum
- nをb進数だとした時の桁和がsになる最小のbを求める問題
- 桁和は
```cs
f(b,n) = n<b? n : f(b,n/b)+n%b
```
- で求める
- まず`s==n`のとき。明らかに答えは`n+1`
- そうじゃないとき
  - 初めに`2 <= b <= Sqrt(N)`の範囲を全探索する
  - 次に`b>Sqrt(N)`の範囲を探索するがここで式を立てる
    - `b>Sqrt(N)`ということはNはb進数で表すとき2桁以上の数字になる
    - このときの上位桁をp,下位桁をq(どちらもb未満)とすると
      - `n = pb+q`
    - になる。ここで条件`b>Sqrt(N)`から
      - `n=pb+q => pb > p^2`
      - `n>p^2`
      - `p<Sqrt(n)`
    - が成り立つ
    - さらに
      - `s=p+q`
    - なので、式から
      - `b=(n-s)/p+1`
      - `n-s=p(b-1) `
    - がもとまる。
  - 以上よりpからbが一意に求まり`Sqrt(N)`の範囲になることが分かるのでこれを全探索する
  - オーダーは全体で`O(Sqrt(N))`

# ABC089 D Practical Skill Test
- H×WマスにA[i,j]が書いてある。(x,y)=>(i,j)と移動するときにAbs(x-i)+Abs(y-j)のコストがかかるときLiが書いてあるマスからRiが書いてあるマスへいくコストはいくつかをQ個答える問題
  - ただし移動はD飛ばしでしかできない（Ri-Li)%D==0は保証される
  - さらにA[i,j]は全て違う
  - 文章力
- ワーシャルフロイドっぽいけど頂点数が最大で90,000なのでTLE
- D飛ばしで道が作られていくことを考えると、1~Dを始点としたD本の道ができることが分かる。
- これについて累積和をとりimos[Ri]-imos[Li]を出せばいい
- 提出を見て賢いと思ったimosの方法をメモ
```cs
int H = NextInt(), W = NextInt(), D = NextInt();
var dic = new Map<int, ti2>();

H.REP(y => W.REP(x => { dic[NextInt()] = new ti2(x, y); }));

var imos = new int[H * W+1];

for (int i = 1+D; i <= H*W; i++) {
	var s = dic[i];
	var t = dic[i - D];
	imos[i] = imos[i - D] + Abs(s.Item1 - t.Item1) + Abs(s.Item2 - t.Item2);
}

NextInt().REP(i =>
{
	int li = NextInt(), ri = NextInt();
	(imos[ri]-imos[li]).WL();
});
```

# ARC064 D An Ordinary Game
- 高橋君と青木君が文字列Sの両端以外の文字1つを選んで取り除くことを交互に行う。取り除いた時に同じ文字が隣り合ってしまうならその文字は取り除けない。さきに取り除けなくなった方の負け
- これも始まった瞬間に勝敗が決まっている系
- 勝敗が決まったときの文字列Sの状態を考えと「abababababa...」となっていることが分かる
  - 「abc」となっているところは真ん中を取り除けばいいので
- 次に勝敗が決まったときの文字列Sの長さを考えたい
- 「abababab...」という状態は
  - 「abababa....bab」　偶数長
  - 「abababa....baba」　奇数長
- のどちらかである。
- 両端の文字は取り除けないのでゲーム終了時には↑のどちらになるかは最初の段階でわかる
- 最初の長さと終了時の長さの偶奇が解るので、取り除く操作が何回行われたかの偶奇が解る
  - これが偶数のとき最後に操作したのは青木君
  - 奇数のときは高橋君
- よって「最初の長さ」と「端っこが同じ文字かどうか」から勝敗が解る
- `O(1)`

# ARC067 D Walk and Teleport
- 横一直線に並ぶN個の町がある。町iから町jへ移動するときにコストBを使ってテレポートするか、コストA(X[j]-X[i])を使って歩くかをする。
- 全ての町を回ったときの最小コストはいくらか
  - 超！貪欲法
- 町を前から順番に回っていくのでOK
- 歩くコストとテレポートコストのMinを取ってSumするだけ
  - はいって感じ
- `O(N)`

# ARC069 D Menagerie
- oとxからなる文字列Sと二種類の動物狼と羊がいる。oの箇所に羊がいるとその両端の動物は同じで、xだと違う動物。狼の場合はこれの逆であるとき文字列Sを満たすような動物の並び方は存在するかを求める問題
  - 初めてといたときはめっちゃ苦しんだ思い出
- この問題では先頭の2匹を決めてしまえば後の並びがすべて決まる。
- この先頭の二匹の並びは4パターンしかない
  - 羊羊
  - 羊狼
  - 狼羊
  - 狼狼
- 並びを作り上げたが、先頭の二つは仮に決めただけなのでこれが間違ってるかもしれない
- そこでN+2の長さの並びを作る
- 後ろの二つは先頭の二つと位置的には一緒になるのでこれが矛盾しないかをチェックする
  - 具体的には後ろの二つが先頭二つと一致してればOK
- 4パターンのうち1つでも矛盾しないものがあればそれを出力。なければ-1
- `O(N)`

# ARC071 D 井井井
- N×Mのマス目（等幅でない）内に存在する長方形の面積の合計を求める問題
  - 激ムズ
- まずこれを愚直に求める式を立てる
  - Sum((x[j]-x[i])×(y[l]-y[k]))
- 当然だがi,j,k,lはN,MなのでTLEする
- これを式変形すると
  - Sum(x[j]-x[i])×Sum(y[l]-y[k])
- というふうにXとYを独立させられる
- しかしこれでもTLEする(O(N^2)なので)
- Sum(x[j]-x[i])を展開してみると
  - Sum(x[j]-x[i]) = x[1]-x[0]+x[2]-x[0]+x[3]-x[0]....
- というふうになる。ここでx[k]が何回足されるかを考えると、k-1回であることがわかる
- 同時にx[k]が何回ひかれるかというと添え字がk以上の回数引かれるのでn-k回。
- つまり式変形をすると
  - Sum((k-1)×x[k]-(n-k)×x[k])
- になるこれは`O(N)`なので間に合う
- Yについても同じで、これらの結果を掛け合わせると答えになる。
- `O(N+M)`

# ARC072 D Alice&Brown
- それぞれX個,Y個の石がある山から2i個とり片方の山にi個戻すゲームで、先手が勝つか後手が勝つかを求める問題
- X+Y >= 1 && |X-Y| <= 1のとき
  - どんな操作をしても|X-Y|>1で相手に手番を渡すので相手が行動できてしまう⇒負ける
- X>Y >= 1 && |X-Y| > 1のとき
  - 多く石がある方から適切に意思を取れば|X-Y|<=1にできるので相手に 手番が回らない⇒勝つ
- これを帰納的に考えると、最初の段階で|X-Y|<=1であればBrownが勝つことが分かる。
- `O(1)`

# ARC074 D 3N Number
- 3N個からN個取り除いた2N個の前半部分と後半部分の差の最大を求める問題
- N~2Nの範囲で境界線を動かす。この境界線はkとする
- 前半部分は最大化、後半部分は最小化することを考えると
  - 0~kの範囲で大きい順にN個の合計
  - k~3Nの範囲で小さい順にN個の合計
- の差の最大値ご答えになる。
- さてこの最大値N個を効率的に求めるのにPriorityQueueを使う
  - EnqueueとDequeueがともにlogNなので毎回ソートするより速い
- 前半部分N個の合計をASUMとすると
```cs
for(int k=N;k<=2*N;k++){
    ASUM+=A[k];
    pq.Enqueue(A[k]);
    var src=pq.Dequeue();
    ASUM-=src;
    max[k]=ASUM;
}
```
- こんなふうに求める。後半について求めるときはComparerを変更して降順に並ぶように変更してもいいがA[k]の値を-1倍すればOK
- `O(N)`

# ARC076 D Built?
- N個の町がある。(x,y)=>(i,j)へ移動する道をMin(|x-i|,|y-j|)で作れる。
- 任意の2点間をいくつかの道を通って移動できるようにするにかかる最小のコストはいくらかを求める問題
  - 最小全域木だってのは解ったけど辺の削り方が解らなかった
- 町がN個あるので辺の数はN^2個ある。これを全部列挙するだけでTLEする
- ここから辺を減らすことを考える
- 先ずは辺のコストについて
  - 辺のコストはMin(|x-i|,|y-j|)で計算できる。
  - 最小全域木では多重辺になっていても問題ない（辺のコストでソートするので小さい方しか選ばれない）
  - なので任意の2点間に`|x-i|,|y-j|`の２本の辺があると考えて問題ない。
- 次に辺の減らし方について
  - x座標と頂点番号の組を(x,i)で表すとき
    - 1:(s,a) < 2:(t,b) < 3:(u,c)
  - という組み合わせがあったとする。
  - ここで1=>3の辺を最小全域木で使うとき、そのコストは`u-s`になる。
  - しかしこの辺は以下みたいに分割できる
    - `u-s = u-t + t-s`
  - つまりこれは
    - `1=>3 = 1=>2=>3`
  - ということになる。これはソートされたx座標間のコストについて1以上先の点との距離は考えなくてもいいことになる（それまでの和と同じ）
  - yについても同じことがいえるので、x,yそれぞれをソートし、隣り合う2点間での辺、|x-i|,|y-j|をそれぞれ計算し、辺のリストに追加していく
    - 辺の数は2N個になる。
  - これをクラスカル法なりで計算すればAC
- クラスカル法のクラスバグってたので直した

# ARC083 D Restoring Road Network
- 全点間距離っぽいグラフが与えられるので矛盾がないかを求める問題
  - 矛盾がなければ道の長さの総和を出力する
- Nが300なので総和の出力がなければワーシャルフロイドはいだった
- 総和の出し方を求める。
  - ワーシャルフロイドの中にちょちょいと組み込めばOK
  - まず入力のグラフをgとdにコピーする
  - ワーシャルフロイドを書く
  - チェックのときに
    - `if(g[i,j]+g[j,k]<d[i,k]){"-1".WL();return 0;}`
    - `if(g[i,j]+g[j,k]==d[i,k]) d[i,k]=int.MaxValue`
  - を書く。辺が2辺による組み合わせでなっているなら二重加算防止のために除外する
- 最後にdの合計を取ればOK
- `O(N^3)`

# ARC085 D ABS
- 最初X,YさんはそれぞれZ,Wというカードを持っている。ここからN枚のカードを前から順番に1枚以上取っていくことを繰り返す。
- 最後にとったカードの絶対値がゲームのスコアになる
  - Xさんは最大化Yさんは最小化することを目標にして行動するときの最大スコアはいくつか
- N=1のとき明らかに`|A[0]-W|`
- N>1のとき先手のXさんはスコアを最大化することだけを考える。
  - 相手にスコアを下げさせないためには相手から選択肢を奪えば良い
  - つまり「全部取る」か「1枚だけ残す」かを行う
    - 途中で値が最大のカードを取ったところでYさんの行動からスコアが最小化されてしまう。
  - 問題の答えは最大得点を求めるのではなく最適行動をする二人の未来
  - 結局答えは`Max(|A[N-2]-A[N-1]|,|A[N-1]-W|)`
- `O(1)`

# ARC088 D Wide Flip
- 0,1からなる文字列がある。この文字列の長さK以上の区間に対して、0,1を反転する操作をするとき、すべてを0にできるような最大のKはいくつか
  - 最小なら1なのでらくだったｗ
- nを文字列の長さとする
- k文字目とk+1文字目が違うとき
  - どちらか片方だけを書き換えるようなKが必要。
  - つまり`Max(k,n-k)`
- 文字列全体でこの`Max(k,n-k)`を見たときの最小値を`t`とすると、最初のk文字か最後のn-k文字を書き換えることで連続する不一致部分を1つ減らせる。
- もしこのtが0（全部0か1）ならKはnと等しくなる。
- これを前から見ていくだけなので`O(N)`

# ARC089 D Checker
- N個の要求`(x,y,c)`は座標`(x,y)`が色`c`であってほしいとき、盤面に`K×K`のサイズの黒と白の市松模様を動かしN個の要求を満たせる最大個数はいくつなのか求める問題
  - 全探索は言わずもがなTLE
- 盤面を小さくすることを考える
  - マス`(x,y)`が白は`(x,y+K)`が黒とおなじ（市松模様なので）
  - これでN個の要求を全部黒についての要求にできる
  - さらに`(x,y)`と`(x+2K,y)`もしくは`(x,y+2K)`と同じ色になる（市松模様なので）
  - なので全ての要求にたいして`(x%2K,y%2K)`とすれば盤面を`2K×2K`にまで落とし込める
- 小さくした盤面で、どのマスに何個の黒要求があるのかを記録する。
  - あとのためにこれを累積和とっておく
- ここからK×KにそれぞれについてK×Kの黒の部分の右上、右下、左上、左下にある時満たせる要求の数の合計を求める
  - これにはさっきつくったimosを使う
```cs
Func<int, int, int, int, int> func = (y1, x1, y2, x2) =>
{
	var a = x1 == 0 ? 0 : imos[y2, x1 - 1];
	var b = y1 == 0 ? 0 : imos[y1 - 1, x2];
	var c = x1 == 0 || y1 == 0 ? 0 : imos[y1 - 1, x1 - 1];
	return imos[y2, x2] - a - b + c;
};
```
- これの最大値が答え。むっずい
- `O(N+K^2)`

# AGC001 B Mysterious Light
- AtCoder 天才以外お断り Contest
- 三角形内を反射する光の軌跡の長さを求める問題
  - ただし光は自分の軌跡にぶつかっても反射する
- 死ぬほど図を書いて考えたけど無理だったｗ
- 最初、三角形内を2回反射すると平行四辺形ができる。これの各辺の長さは`X,N-X`。
- この平行四辺形の中を2回反射するまでに進む距離を`rc(a,b)`とする。
  - さらに2回反射するとまた平行四辺形ができる。
- ここで`a<b`のとき
  - `rc(a,b) = rc(b,b-a)+2a`
  - `rc(a,a) = a`
- である。なので再帰をかけばいいけどこれだとTLE
- TLEする原因は`a<<<<<b`って時があるから
  - こういう時は遷移を纏めてする必要がある（長さbの線分の上にaの三角形がb/a個乗っているのでまとめて遷移できる）
- これを式に落とすと
- `rc(a,b) = (a%b==0) ? 2a(b/a)-a : rc(a,b%a)+2a(b/a)`
  - `b%a`の意味だが、長さbの線分の上にaの三角形がb/a個乗っていることを考えるとbはaずつ消費されるので残りは`b%a`になる。それだけ
- これなら`O(logN)`で計算できる。激ムズ

# AGC002 C Knot Puzzle
- N個のロープがある。このロープは最初1本になっている。このロープに以下の操作をN-1回行う
  - 長さがL以上のロープを選び、そこに結び目があればそれをほどく（2本に分ける）
- 操作をした後全部をバラバラにできるかという問題
  - 比較的優しい
- 最後のA[i]+A[i+1]をほどくとき、これは必ずL以上の長さでないといけない
  - つまり`A[i]+A[i+1]>=L`が一つもない時が不可能なパターン
- 逆にいうとこの部分があれば必ずバラバラにできる
  - `A[i]+A[i+1]>=L`を残したまま左右を解いてけばOK
- このiをpとすると解く順番は`1,2,....p-1,N-1,N-2,...,p+1,p`という順番
- `O(N)`

# AGC010 B Boxes
- N個の箱にそれぞれA[i]個の石が入っている。i番目の箱を選んだ時、i番目からは1つ、i+1番目からは2つ、(i+j)%N番目からはj+1個取り出す
- 適切に箱を選んで石を0個にできるかという問題
- どの箱を選んでも全体として減る石の数は(N(N+1))/2個である。（自明）
  - 石の総数がこれの倍数でなければNO
- 減る石の数と総数から何回操作をするかが求まる。
  - この値をkとする
- 次にi+1とi番目の石の変化を見てみる
  - A[i+1]-A[i]を列挙してみると
  - 一回の操作で1つだけ`+(N-1)`されて他は`-1`されることが分かる
  - -1はk回行われるのでこれをリストアップしてみる
- `d={A[i+1]-A[i]-k}`
- これの各要素が
  - 負数である
    - あとはk回Nが加算されるだけなので
  - Nの倍数である
    - Nが加算されるので
  - k回の操作ですべて0にできる
    - そもそもの目的なので
- を満たしているかをチェックすればAC
- `O(N)`

# AGC013 B Hamiltonish Path
- 無効グラフのハミルトン路を求める問題
  - 必ず存在することが保証されている
- 必ずハミルトン路があるのでDequeやLinkedListなどで貪欲をやるといい
- まず頂点0とそれにつながっている頂点を仮のハミルトン路の端っこだとする
  - これをLinkedListに追加しておくこれがハミルトン路を表す
- 以下の操作を全ての頂点を通るまで繰り替えす
  - ハミルトン路の端っこ2点を取り出す
    - sとtとする
  - グラフでsにつながる頂点kをみる
    - kが既に既に通った頂点ならスキップ
    - 通ってないならハミルトン路の端っことしてsの前に追加する
    - ここまでで更新があったら戻る
  - グラフtにつながる頂点lをみる
    - lについても同じように操作する
    - tの後に追加するようにする
  - ここまでで更新がないならハミルトン路が完成している
```cs
while (true) {
	var s = ll.First.Value;
	var t = ll.Last.Value;
	used[s] = used[t] = true;
	bool updated = false;
	foreach (var node in g[s]) {
		if (used[node]) continue;
		ll.AddFirst(node);
		updated = true;
		break;
	}

	if (updated) continue;
	foreach (var node in g[t]) {
		if (used[node]) continue;
		ll.AddLast(node);
		updated = true;
		break;
	}

	if (updated) continue;
	break;
}
```
- あとは出力するだけ

# AGC014 B Unplanned Queries
- パス(a,b)にある辺すべてに1加算するクエリをM回繰り返す。これが終わった後木の辺が全て偶数な木はあるかどうか
- 簡単にいうと全ての頂点が偶数回出てくるかどうかをチェックすればいい
- (a,b)というパスは(r,a)=>(r,b)というパスに分解できる。
- a,bのLCAがpだとしたとき
  - (a,p),(b,p)は+1,(r,p)は+2
- にさらに分解できる。
  - なので(a,b)が偶数回でてこれば、これについてのパスが偶数でできていることが保証できる
- これを全ての点に対してチェックすればOK
- `O(N+M)`

# AGC019 B Reverse and Compare
- 文字列Sの区間l,rを1回だけ反転させてできる文字列の種類はいくつか
- `A[i]==A[j]`のとき区間[i+1,j-1]をひっくり返した結果は区間[i,j]をひっくり返した結果と同じになる
  - なのでA[i]==A[j]となるi,jについては考えなくてOK
- 答えは(i<j && A[i]!=A[j],のようなi,jの個数)+1
- これは全ての組の個数からN(N-1)/2からi<jでA[i]==A[j]であるような組の個数を引けばいい
  - 愚直に数えると`O(N^2)`
- `k(c) = Sに含まれているcの個数`
- を定義しておくと
  - `同じ文字の組の個数 = a->z k(c)(k(c)-1)/2`
- `O(N)`

# AGC020 B Ice Rink Game
- AtCoder tourist Contest
- A[i]人グループを作っていきあぶれた人が脱落するゲームでK個目までやったとき2人になった。元のN人の最大と最小はいくつか、不可能なら-1を出力
  - まだらく
- まずA[N]!=2のとき明らかに-1
- 次にA[i]番目のグループ作成をiゲーム目と呼ぶとして、状態を考える
  - iゲーム目の最大値をR[i],最小値をL[i]とする。L[K],R[K]は2,2
  - iゲーム目が終わったとき人数はA[i]の倍数であるはず
  - このときLiとRiの間にA[i]の倍数が存在しなければこれは不可能
  - もしそのような数が存在するなら
    - `L[i-1] = Celing(L[i]/A[i])×A[i]` L[i]を超える最小のA[i]の倍数
    - `R[i-1] = R[i]/A[i]×A[i]+A[i]-1` R[i]を超えない最大のA[i]の倍数
  - で計算できる
- プログラム的にこれらを賢くかこう
- `O(K)`
```cs
A.Reverse();

var max = 2L;
var min = 2L;


foreach (var item in A) {

	if ((min-1)/item!=max/item) {
		min = ((min - 1) / item + 1) * item;
		max = (max / item + 1) * item - 1;
	}
	else {
		"-1".WL();
		return;
	}
}
```

# APC001 C Vacnt Seat
- インタラクティブな問題その2
- N個の席が円状に並んでいる。同性同士が隣に座ることがない。席iに座っている人の性別が20回まで質問できるので、開いている席を1つ見つける問題
  - Nが99,999までなので2^20未満。なので二分探索
- まず0を質問する。答えをresとfrontに格納する。
  - Vacantなら終わり
- l=0,r=N-1で二分探索を始める
  - m=(r+l)/2として、mを質問する。resに返答を受け取る
    - Vacantなら終了
  - mが偶数でres==front　もしくは　mは奇数でres!=frontならl=m+1
  - ちがうならr=m-1
- これを19回まで行う。絶対1つに絞れるのでこれでOK

# CODE FESTIVAL 2016 Grand Final A - 1D Matching
- 1次元に並んでいるPCと電源を1対1で接続していく。その長さの合計が最小になる組み合わせはいくつあるか
  - 解説が簡単すぎて解説の解説が必要な問題
  - http://ferin-tech.hatenablog.com/entry/2017/12/18/211329
- 区間がないか探してみる。
  - PCを+1,電源を-1としてimosして、累積和が0になった部分までを1つの区間としてみると電源⇒PCという矢印が1方向しか向かないことが分かる
    - `k={PC,PC,AL,PC,AL,AL}` これは `k[0]=>k[2],k[1]=>k[4],k[3]=>k[5]`というふうにつなぐのが最小
  - なのでこの区間ごとに組み合わせが独立している
- PCと電源を座標で並べ替えるとPCと電源でランレングスみたいなのができる。
- 上の参考のテストケースを使うと
```
電源,電源,電源,PC,PC,電源,PC,電源,PC,PC  
              電 PC 電 PC 電 PC
連続してる数  3  2  1  1  1  2
     何通り  1  6  6  12 12 24
残りの電源数  3  1  2  1  2  0
```
- 今注目しているのが電源のときは残りの電源数に加算する
- PCで、PCの数が電源数以下なら答えに`Combination(電源数,PC数)×PC数!`を追加する。
- そうでないなら電源対PCは(電源数!)個しか組み合わせがないので答えに加算する。このときPCと電源は入れ替わる（見るのは残りの電源数から残りのPC数にかわる）
```cs
var al = 0L;
var T = true;
foreach (var item in box) {
	if (T) {
		al += item;
	}
	else {
		if (al >= item) {
			var x = Mod(Combination(al, item) * factorial[item]);
			ans = Mod(ans * x);
			al -= item;
		}
		else {
			ans = Mod(ans * factorial[al]);
			al = item - al;
			T = !T;
		}
	}

	T = !T;
}
```

# CODE FESTIVAL 2016 Grand Final: B Inscribed Bicycle
- AtCoder 幾何問題 Contest
- 三角形の内部に半径が同じ円を二つ重ならないように書きたい。この円の最大の半径はいくらか
- 内接円の半径をr,各辺をa,b,cとする
- 内部に半径xの円を描くことを考えたとき、各辺からxだけ離れた内部に中心点があるときだけこの半径xの円を描くことができる
- こういうxの分布は三角形になり、外側の三角形と合同でしかも(1-x/r)倍の大きさになっている。
- この小さい三角形にある2点間の距離が2x以上にできるとき、半径xの円を二つ書くことができる（この2点は小さい三角形の辺のうち最大の長さを作る2点）
- なのでこれを式にする
  - `(1-r/x)Max(a,b,c)=2x`
- 変形して
  - `x = rMax(a,b,c)/(2r+Max(a.b.c))`
- `O(1)`

# CODE FESTIVAL 2016 Grand Final: C Cheating Nim
- Nimを始める前に後手がk個の山から1減らすことができるとき、後手が必勝になる最小のkはいくつかという問題
  - 勝てないなら-1
- Nimは各山のxorの総和が0のとき負けるというのが解ってる（grundy数で検索）
- なので最初はDPだと思った
  - dp[i][j] = i個目まででjにできる最小のk
- これだと状態が多すぎるのでダメ
- `a[i]=>a[i]-1`としたときの差分は`a[i]xor(a[i]-1)`になるがこれは2^b^-1の形になっている。
- 0とのxorの結果が0にならないといけないので各ビットについて1が1つはないとダメになる
  - 実際には10^9^まででいいので2^30^の各ビットについて1が1つはないとダメ
- そしてどのビットがあるかというのはCTZ(最下位ビットから0が何個続くか)でわかる
- なので総和からbの大きい順に差分を引いて0にしようとすればいい
```cs
Func<int, int> Ctz = (x) =>
{
	var rt = 0;
	while (x % 2 == 0) {
		rt++;
		x >>= 1;
	}

	return rt;
};

int res = 0;
for (int i = 29; i >= 0; i--) {
	if ((sum & (1 << i))!=0) {
		if (!box[i]) {
			res = -1;
			break;
		}
		else {
			res++;
			sum^= (1 << (i + 1)) - 1;
		}
	}
}
```

# ABC090 D Remainder Reminder
- N以下の整数a,bがある。a%b>=Kとなるa,bの組み合わせは何個あるか
  - 時間中に解けなかったよ
- bを固定することを考える
  - こういう変数が2つ以上ある問題はどちらかを固定すればわかりやすいらしい
  - bの取りうる範囲は[K+1,N]である
- さらにp,rを使って`N=pb+r`と表すことにする。
  - このときaを0~Nの範囲で動かすとすると
    - `0,1,2,3,...,b-1,0,1,2,3,...,b-1,...,0,1,2,...,r`
  - となる。
  - この数列のなかには[0,b-1]がp回出てくる。pは`N/b`で計算できる。
    - [0,b-1]の中にK以上の数が何個あるかは`Max(b-K,0)`である
  - さらに[0,r]の範囲にK以上の数字は`Max(0,r-K+1)`個ある
- これを各`b`について計算した合計が答えになる
  - こういう問題が超苦手なのがわかったので精進したい
- `O(N)`

# CODE FESTIVAL 2016 qual B C Gr-idian MST
- グリッドグラフの最小全域木を求める問題
  - 辺は(i,j)=>(i+1,j)のときはp[i]を。(i,j)=>(i,j+1)のときはq[j]を使う
- 単純にクラスカル法をしようとすると頂点数と辺数が多すぎてTLE
- なので減らすことを考えてみる
- (i,j)=>(i+1,j)の辺を張ったとき、x座標についてだけ言うとするとiとi+1は同じ点になったといえる（Uniteされた）
- このときyについてみてみるとp[i]の辺がH個あることが分かる。
- つまりx座標に対する辺を1本張ると
  - p[i]の辺がH本最小全域木に増える
  - x座標が1つ減るのでWが1ちいさくなる
- yについてもこれは同じ
- よってp,qの辺を同時にソートし、コストの小さい順に↑の処理をしていく
  - ちなみに結局すべての辺を1回は使うことになる
- `O((H+W)log(H+W))`

# CODE FESTIVAL 2017 Final (Parallel) C - Time Gap
- 数列DからDi or 24-Diを選んで任意の2つの差の最小はいくつかみたいな感じ
- 解説の円が分かりやすい
- Diが何個あるかを記録した`dic`を用意する
  - `dic[0]>=1`のとき、高橋君と位置が被るので答えは0
  - `dic[i]>=3`のとき、i,24-iにどうんな風に振り分けても必ずどちらかに2人以上いることになるので上と同じように0
  - `dic[12]>=2`のとき、12に2人いるので0
  - `dic[12]==1`のとき、12の位置に1人だけいる
  - 0,12についてはこれでOK
- [1,11]について
  - `dic[i]==0`なら、人はいない
  - `dic[i]==2`なら、iと24-iに人がいる
  - `dic[i]==1`なら、iか24-iに人がいる
- dic[i]==1になるパターンが厄介でどちらかにしかいないのでどちらにいる。みたいな全探索をやりたい
- 全探索はTLEしそうだけど実際状態の数は1,2,3,...,11時の人が左右のどちらかにいる = 2^11^個程度しかないので全探索できる
- なのでまずやることは
  - `dic[i]==2`の部分にはi,24-iに人が居るとする
  - `dic[i]==1`の部分はあとで探索するのでlistにとっておく
  - `dic[12]==1`なら12に人をおく
- 取っておいたlistを使って全探索する。
```cs
var M=list.Count;
(1<<M).REP(bit =>
{
	//0~1<<Mまで2^M通り
	M.REP(i =>
	{
		var dx = list[i];
		var dy = 24 - dx;
		//状態は2つ、bitが1なら右側、0なら左側
		if ((bit & (1 << i)) != 0) {
			circle[dx] = 1;
			circle[dy] = 0;
		}
		else {
			circle[dx] = 0;
			circle[dy] = 1;
		}
	});
	ans = Max(ans, search());
});
```
- 状態を作った後最小距離を求めるには
```cs
Func<int> search = () =>
{
	var rt = int.MaxValue;
	for (int i = 0; i < 24; i++) {
		for (int j = 0; j < 24; j++) {
			if (circle[i] < 1 || circle[j] < 1 || i == j) continue; //人が居るときだけ
			var d1 =  Abs(j - i); //距離を2つだす
			var d = Min(d1, 24 - d1);
			rt = Min(d, rt);//Minを取る
		}
	}
	return rt;
};
```
- `O((24^2)M2^M)`,Mは最大11