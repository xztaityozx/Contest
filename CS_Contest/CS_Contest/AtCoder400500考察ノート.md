AtCoder 400,500考察ノート
# ABC051 D Candidates of No Shortest Paths
- ワーシャルフロイドで全点間距離を求める
- 入力された`edge[i,j]`が使われているかどうかは、各点sから
    - ```distance[s,i] + edge[i,j].Cost == distance[s,j]```
- を調べる。

# ABC054 D Mixing Experiment
- 典型的なDP
- `dp[N,aiの合計,biの合計] = 最小コスト `
- `dp[i+1,i,j] = Min(dp[i,j,k],dp[i+1,j,k])`
- `dp[i+1,i+ai,j+bi] = Min(dp[i,j,k]+ci,dp[i+1,j+ai,k+bi])`

# ABC057 D Maximum Average Sets
- DPっぽいけど違った
- `v`を降順にソートし先頭からA個の平均が最大値（これは自明）
    - A+1個目を足しても平均は下がる一方（降順に並んでるから）
- v[0]とv[A-1]が同じ値のとき
    - 最大値がA個以上続いているかもしれない
    - vの中にv[0]がX個あるとき
    - 組み合わせ`XCi` `(A<=i<=B)`の合計が答え
- v[0]とv[A-1]が違うとき
    - 先頭からA個のうちに最大値がY個あったとすると答えは XCYになる
- 組み合わせはパスカルの三角形で求める
    - 前計算はO(n^2)
    - アクセスはO(1)
```cs
public static long[,] CombinationTable(int n) {
    var rt = new long[n+1, n+1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            if (j == 0 || i == j) rt[i, j] = 1L;
            else rt[i, j] = (rt[i - 1, j - 1] + rt[i - 1, j]);
        }
    }
    return rt;
}
```

# ABC061 D Score Attack
- 閉路検出が必要だったのでトポロジカルソートかと思ったけど違った
- コストの正負を逆にして最短経路を出す。負数が表れるので使うのはベルマンフォード法
- BellmanFordクラスを作ってループがあるかどうかのプロパティも持たせた
- ベルマンフォードで閉路が見つかったら`inf`、無ければ`-Distance[N-1]`が答え

# ABC070 D Transit Tree Path
- 重み付き木に対して`xi⇒K⇒yi`を通る最短距離の質問に`Q`個答える問題
- 事前に点KからダイクストラしておけばTLEしない
- その後Q個の質問に対して`Distance[xi]+Distance[yi]`を出力すればOK

# ABC073 D joisino's travel
- 訪問しなければならない点を全て訪れたときの最小コストを求める問題
  - 順番は何でもOK
- 制約が小さいのでワーシャルフロイド法＋DFSで解く
- 1次配列で訪れた点を記憶する方法いつも忘れるのでメモ
```cs
//Rは訪れる点の個数
//resはワーシャルフロイドの結果
var used = Enumerable.Repeat(false, R).ToList();

Func<int, int, long, bool> dfs = null;
dfs = (step, before, distance) =>
{
	if (step == R + 1) {
		min = Min(min, distance);
		return true;
	}

	R.REP(i =>
	{
		if (used[i]) return;
		used[i] = true;
		if (before == -1) dfs(step + 1, i, 0);
		else dfs(step + 1, i, distance + res[rList[i]][rList[before]]);
		used[i] = false;
	});
	return true;
};
```

# ABC076 D AtCoder Express
- 与えられたN個条件を満たすような台形の面積を求める問題。
- 各点を記憶していくのは実装がバグるので絶対やめた方がいい
- この問題では時刻Xがすべて整数なので、時刻が0.5の倍数のとき傾きが変化する。
- そのため`時刻a(aは0.5の倍数)`での出せる最大の速度を`v(a)`とすると、`(a(a)+a(a+0.5))/4`の合計が答えになる
- 0.5刻みの配列を表現するために時間を2倍に拡張して1要素が0.5を表すようにする。
```cs
var time = 0;

N.REP(i=>(T[i]*2).REP(k =>
{
	box[time] = Min(box[time], V[i]);
	time++;
	box[time] = Min(box[time], V[i]);
}));
```
- 時刻`time`のときにとりうる最大値を`Min`を使って得る。超えてはいけないのでMin
```cs
for (var i = 1; i < sum; i++) 
    box[i] = Min(box[i], box[i - 1] + 0.5, box[i + 1] + 0.5);
for (var i = sum-1; i >= 1; i--) 
    box[i] = Min(box[i], box[i - 1] + 0.5, box[i + 1] + 0.5);
```
- 次に前後から整合性を取る。
  - 時刻`i`の速度はその前後の`±0.5`かそれ自身であるはずなのでそのうちの最小値が正確な値となる
- あとは和を計算して終わり

# ABC079 D Wall
- 数値`x`を`1`にする問題。`x`から`1`にするには`A[1][x]`のコストがかかる。
- `A[][]`が`10×10`なのでワーシャルフロイドで全点間最小距離を求めて-1,1を省いたあとsumすればおわり
- やるだけって感じだけど有向グラフなので注意

# ABC080 D Recording
- 累積和問題。ばぐらせてつらい
- S+0.5の期間～～みたいなことが書いてあるので取りうる数値を2倍にした配列用意してimosする
- このとき各チャンネルごとにimosすると楽になる
- レコーダーは`S-0.5`から使えなくなるので
```cs
imos[ci-1,si*2-1]++;
imos[ci-1,ti*2]--;
```
- とするとうまくいく
```cs
C.REP(i=>{
    (100005*2).REP(j=>{
        if(j!=0) imos[i,j]+=imos[i,j-1];
        if(imos[i,j]>=1)REC[j]++;
    });
});
REC.Max().WL(); // こたえ
```

# ABC084 D 2017-like Number
- 時間中に解けなくて辛すぎた問題。
- 条件にあう素数リストを事前に求めてimosで数え上げをする。
- `yield return`でエラトステネスの篩を高速化（コピペ）したのでメモ
```cs
public static IEnumerable<int> Primes(int maxnum) {
	yield return 2;
	yield return 3;
	var sieve = new BitArray(maxnum + 1);
	int squareroot = (int)Math.Sqrt(maxnum);
	for (int i = 2; i <= squareroot; i++) {
		if (sieve[i] == false) {
			for (int n = i * 2; n <= maxnum; n += i)
				sieve[n] = true;
		}
		for (var n = i * i + 1; n <= maxnum && n < (i + 1) * (i + 1); n++) {
			if (!sieve[n])
				yield return n;
		}
	}
}
```
- `IEnumerable`で`yield`使うのすっかり忘れてた・・・反省したい
  - これに`Where(x=>IsPrime((x+1)/2))`すれば条件に合う素数リストができる
```cs
public static bool IsPrime(int n) {
	if (n == 2) return true;
	if (n < 2||n%2==0) return false;
	var i = 3;
	int sq = (int)Sqrt(n);
	while (i <= sq) {
		if (n % i == 0) return false;
		i += 2;
	}
	return true;
}
```
- 時間中にバグらせてたのは範囲の指定を`imos[ri+1]-imos[li]`じゃなくて`imos[ri]-imos[li-1]`で計算してたこと
  - imosむずい

# ARC058 D いろはちゃんとマス目 / Iroha and a Grid
- 問題をかみ砕くと升目上を最短経路で移動するとき、`(0,0)=>(H-A-1,i)=>(W-1,H-1)`へ移動するパターンを数え上げる問題になる
  - ただし`B <= i < W`
- これを逆に考えると通ってはいけないルートを通るパターンを全体から引けば良いというのが分かる
- `n×k`マスの升目の最短経路の個数は`(n+k)Ck`で計算できる。
  - これを毎回計算するとTLEするのでテーブルを作る
  - `nCk`は、`(n+k)!/(n!k!)`で求められるのでこれを用意したい。
- パスカルの三角形より大きな数を用意できるけど、小さな値ならあっちのがはやい
```cs
var factorial = new long[100001 * 2];
var inverse = new long[100001 * 2];
factorial[0] = inverse[0] = 1;
for (var i = 1; i <  factorial.Length; i++) {
	factorial[i] = Mod(factorial[i - 1] * i);
	inverse[i] = ModPow(factorial[i], ModValue - 2);
}

Func<int, int, long> Combination = (n, k) =>
{
	if (n - k < 0) return 0;
	var rt = factorial[n];
	rt *= inverse[k];
	rt %= ModValue;
	rt *= inverse[n - k];
	return Mod(rt);
};
```
- これで組み合わせに`O(1)`でアクセスできるのでこれを利用する。
- あとは`A×B`の各点を経由して右下まで移動するパターンを全体から引いていくことでAC

# ARC089 D アンバランス / Unbalanced
- 部分文字列に1つの文字が過半数含まれているかを探す問題
  - 部分点はSの長さが100なので全探索でも間に合う
  - 満点取るには全探索じゃTLE
- ある文字列についてその過半数がアルファベットXであるということは
  - XX
  - XYX(Yは任意)
- のどちらかが含まれていることになる。
  - これらがない場合1種類の文字の間に必ず2文字別の文字が挟まることになる
  - 過半数を超えることはないためアンバランスになりえない
- これをチェックすればいいので`O(|S|)`で解ける

# ARC061 D すぬけ君の塗り絵 / Snuke's Coloring
- H×Wマス内の全ての3×3マスに何個の黒マスがあるかを数え上げる問題。
  - 制約が大きいため全探索は不可能
  - 平面imosっぽいけど全然違った
- あるマス(x,y)が黒であったとき、そのマスを含む9個の3×3マスが存在する。
- この9個のマスが何回出てきたかを記録する。
  - 出てきた回数がその3×3マスに含まれる黒マスの個数になる
  - 0個含まれるのは(H-2)×(W-2)から↑で求めた総数を引くと解る
- こういうX,Yの組み合わせを`Dictionary`の`Key`に使う場合`Tuple<long,long>`を使うとTLEする。（した）
  - これを爆速にするには`long`にしまい込む方法がある。
  - 今回は`ai,bi`ともに10^9なので`pos=ai*1000000000+bi`とすれば一意の組み合わせを`Tuple`とか使わずに表現できる。
    - 10倍ぐらい速度が違う

# ARC065 D 連結 / Connectivity
- 二つのグラフが与えられる。頂点iと頂点jが二つのグラフともに連結かどうかを調べる問題
  - 出力は頂点iに対して頂点jが何個あるかを列挙する。
- 連結かどうかを調べたいので`Union-Find`を使えばここは一撃。
  - 問題は個数の列挙
  - 頂点i,jが二つのグラフでともに連結は、鉄道のUFを`ufK`,道路のUFを`ufL`とすると
    - `ufK.IsSameGroup(i,j) && ufL.IsSameGroup(i,j)`
  - Nが`2×1e5`なのでこれを愚直に全探索は不可能
- ここでUFの特徴を考える
  - それぞれの要素（今回はそれぞれの町）について連結しているグループの親は1つ。（親の親は自信）
  - 各町iについて二つのUFから`親の組み合わせ`が列挙できる。
  - 親の組み合わせがいくつあるかが答えになる。
    - これを各町iについてへ復元しないといけないが解説はここでソートを使うって書いてた（わからん）
  - 組み合わせを数える`Dictionary`と町iがどの組み合わせだったからを記録する配列を用意して町iの情報を`O(N)`で作る。
  - `Dictionary`と配列から情報を復元して`StringJoin(" ")`すればAC

# ARC073 D Simple Knapsack
- 普通のナップザック
- `Dictionary`使う実装の方がREださなくて済む

# ARC074 C Chocolate Bar
- チョコレートに見立てたマス目を3つに分割して最小の面積と最大の面積の差のMinを探す問題
  - C問題のくせに400点という暴力
- 分割の方法は`T`か`≡`か`川`か`ト`の4パターンしかない。なのでこれについてそれぞれ`O(H)`で計算する。
  - このうち`T`と`≡`は向きを変えれば残りの二つのパターンになる。
    - つまりこの二つを計算する関数を作って引数のタテヨコを入れ替えるだけでOK
  - さらに`T`と`≡`は同じループ内で計算できる。
    - 上の横長の領域の高さについて`O(H)`でループする。
    - 面積の計算は`O(1)`
- ようはこんな感じ
```cs
Func<long, long, long> getMinimumDivide = (h, w) => {
	var min = long.MaxValue;
	new Tuple<long, long>(1, h).FOR(ah => {
		//≡
		{
			var bh = (h - ah) / 2;
			var ch = h - (ah + bh);
			min = Min(min, Max(ah * w, bh * w, ch * w) - Min(ah * w, bh * w, ch * w));
		}
		//T
		{
			var bw = w / 2;
			var cw = w - bw;
			var bch = h - ah;
			min = Min(min, Max(bch * bw, bch * cw, ah * w) - Min(bch * bw, bch * cw, ah * w));
		}
	});

	return min;
};
```

# ARC075 D Widespread
- 1体にAダメ、ほかにBダメ与える攻撃を使ってN体の敵を倒すとき、必要な最小の攻撃回数を求める問題
  - Nが10^5なのでimosか二分探索かソートかって感じだとおもった
- 問題を読みかえると`T`回攻撃するとき、それぞれの敵に対して`B×T`ダメージと、任意の敵に`(A-B)×T`ダメージを与えることになることが分かる
  - `T`回の攻撃ですべての敵を倒せるかのチェックは`O(N)`でできる
```cs
Func<long, bool> check = (T) => {
	var at = T;
	foreach (var item in H) {
		var hitpoint = item - B * T;
		if (hitpoint <= 0) continue;
		var req = (int) Ceiling(((double) hitpoint / (A - B)));
		if (req <= at) at -= req;
		else {
			return false;
		}
	}
	return true;
};
```
- この`T`の求め方は二分探索で求める。範囲は`0~H.Max()/B`
  - 計算量は`O(logH.Max()/B)`
- 合わせると`O(N×logH.Max()/B)`なので間に合う

# ARC078 D Fennec VS Snuke
- 木の中で陣取りゲームをする。先にとれなくなった方の負け
- フェネックとすぬけ君がとる最善の行動は先に行けるところまでお互いに近づく行動
  - 相手の行動を1つつぶせるから
  - 進行方向以外の向きに向いてる枝とかはぶつかった後でとれるので後回しでいい
- それを踏まえて考えると各`Node`にたいしてそれぞれのスタート地点からの距離が短い方がそのマスを獲得することができるとわかる。
  - DFSかBFSで0とN-1から各`Node`が何ステップ目にあるかを記録し`d[0,i]<=d[N-1,i]`ならフェネックのマス、そうじゃないならすぬけ君のマスになる
- これを数え上げて比較すればAC
  - たぶんコスト1の辺とみてダイクストラしても行けると思うけどDFSのがかんたん

# ARC080 C 4-adjacent
- 数列を並び替えて隣同士の積がすべて4の倍数になるかを調べる問題
- この数列内には3つの要素がある
  1. 4の倍数
  2. 4の倍数じゃないけど2の倍数
  3. 奇数
- 並び替え方は1の数字とそれ以外が交互に来る並び替え方だとわかる。 
- しかしこのとき2の個数が問題に大きくかかわってくる
  - 2の数字はそれ単体では奇数と同じ役割だが偶数個ずつ集まると4の倍数になれる
  - この問題の場合並び替えるときに2の数字は端っこに追いやればいいので考えないといけないのは追いやったところとガチで並び替えたところの境目
  - この接合部では2の数字と1の数字が隣り合っていないといけない。（奇数と2の数字をかけても4の倍数にはならない）
    - こういう1と3の数字の並べ方は1の個数が3以上じゃないとできない
  - しかし2の数字が1つもないなら、端っこが4の倍数でなくてもいい。
    - こういう並べ方は1の個数が3の個数より1少なくてもいい
- つまり
  - 2の個数が0なら
    - 1の個数+1>=3の個数
  - 1個でもあるなら
    - 1の個数>=3の個数
- がこたえ

# ARC082 D Derangement
- `i==list[i]`となってる部分をXとする
  - 隣り合ったXXは互いに入れ替えればクリア
  - なのでこれを先に処理する
- 次に左と交換できるか右と交換できるかを繰り返してAC

# ARC081 D Coloring Dominoes
- `|`か`=`の形に並んでいるドミノを同じ色が接しないように3色で塗るパターンはいくつあるかを求める問題
- 先頭の組を除いて1つの組を塗る方法は1つか2つか3つしかない。
- 今塗るドミノが`|`のとき
  - 1つ前のドミノが`|`のときはその色以外が使えるので __2通り__
  - 1つ前のドミノが`=`のときは二つの色以外なので __1通り__
- 今塗るドミノが`=`のとき
  - 1つ前のドミノが`|`のときその色以外の上下入れ替えで __2通り__
  - 1つ前のドミノが`=`のときその色の上下入れ替えと片方を含むパターンで __3通り__
- これが解れば先頭からModを取って計算するだけ

# ARC090 D People on a Line
- 重み付き有向グラフに矛盾がないかどうかを調べる問題。グラフがすべて連結とは限らない
  - 解説にはDFSでACと書いてあるけど自分はDFS苦手なので解らない
- 辺の重みもいっしょに管理するUnionFindで解けるらしい
  - [重みつきUnion-Find木とそれが使える問題のまとめ、および牛ゲーについて](http://drken1215.hatenablog.com/entry/2018/02/01/134441)
  - 重み付きUFとかポテンシャルつきUFとか言うらしい。ちゃんとした名前がない
- 重み付きUFは普通のUFに親との重みの差分を持つ
  - 親の重みは0
- 親の重みは必ず0であるので矛盾がない場合は
  - `Parent[i]==i && Cost[i] == 0`
- が必ず成り立つはず
- 重み付きUFに辺を追加していき最後にこれをチェックすればAC

# AGC002 B Box and Ball
- N個の箱があり、箱[xi]から玉を一つ箱[yi]へ移動させることをM回行って、赤い玉が入ってる可能性のある箱の個数を求める問題
  - 可能性を考えるので赤い玉を積極的に動かしていくのがいい
- まず赤玉が入ってるかもしれないを表す`bool box[N]`と箱に何個玉が入ってるかを表す`int count[N]`を用意する
  - 各操作では毎回`count[xi]--`と`count[yi]++`（玉の移動）がある
- 箱[xi]から箱[yi]へ玉を移動させるとき
  - `count[xi]`が1で`box[xi]`が`true`のとき
    - 動かした玉は赤玉なので`box[xi]`に赤玉は存在しない⇒`false`にする
    - 動かした先の箱[yi]に赤玉が移動するので`box[yi]=true`
  - `count[xi]`が1より多く、`box[xi]`が`true`のとき
    - 動かした玉が赤玉 __かもしれない__ ので`box[yi]=true`
    - しかし動かした玉が赤玉 __じゃないかもしれない__ ので`box[xi]=true`のまま
- こうやって求めた`box`が赤玉が入ってるかもしれない（＝可能性）リストにになるので`true`を数え上げればOK

# AGC003 B Simplified mahjong
- 数値iが書かれたカードがx[i]枚あり、数値の差の絶対値が1ならペアにできるとき、できるペアの最大値を求める問題
  - 重要なのはx[i]が偶数か奇数か
- x[i]が偶数のとき
  - 数値iだけで完結するのでノータッチ
- x[i]が奇数のとき
  - 隣り合うi+1かi-1から1枚借りてくることでペアを最大化できる。
    - プロフラム的に前から見ていくので今回はi+1から借りることにする
  - x[i+1]が1枚以上あるときx[i]を偶数にできる（1枚もないならできない）
    - x[i+1]が奇数になる場合もあるがx[i+2]から借りてくる前提
    - x[i+2]が0の場合もあるが、これはx[i]がx[i+1]から借りてこようが結果は一緒になる
      - `1,4,0` ⇒ `2,3,0`と`1,4,0`にできるがペアは2個しかできない
      - `1,4,3` ⇒ そのままだと3ペア。`2,4,2`にすれば4ペア
  - こうやってできるだけ要素を偶数化した配列を用意し、`box.Select(x=>(long)x/2).Sum()`すれば答え
    - オーバーフローするので注意

# AGC004 B Colorful Slimes
- スライムiを作るのに何かを進化させてくるか、素で捕まえるかを選んで最小のコストを探す
- iを手に入れるのに進化をk回するとすると、手に入れるには`min(ai,ai-1,...ai-k)`になります
- これを用いてkを0~N-1の範囲で計算する
  - 計算式は`k×x+Sum(min)`
  - これの最小値が答えになる。`O(N^2)`

# AGC005 B Minimum Sum
- 200,000要素の区間`[l,r](lは1~N,rはl~N)`の最小値の合計を取る問題
  - やはり400点問題には難易度差があるなと感じた1問
- `set`を使う解法は解説を読んだり解説の解説を読んでも解らなかったのでUnionFindを使うやつを採用
  - [AtCoder Grand Contest 005: B. Minimum Sum - pekempeyのブログ](http://pekempey.hatenablog.com/entry/2016/10/02/042213)
- 区間の最小値がvになる区間がいくつあるかを数え上げることを考える
- vの左右の要素がvより大きかったら`Unite`する（同グループになる）
  - このとき連結された方に連結した方の左右につながっているノードの数を加算する（＝サイズ）
  - ノードが持っているサイズがその値が最小値になる区間の数なので、値と区間の数を乗算する
    - これの和が答え
- UFは大きい方からUniteする。
```cs
public void Solve() {
	var N = NextInt();
	long[] a=new long[N],aindex=new long[N];
	N.REP(i =>
	{
		a[i] = NextLong();
		aindex[a[i]-1] = i;
	});

	var suf = new SectionUnionFind(N);

	var ans = 0L;
	for(var k = N-1; k >= 0; k--) { 
		var i = (int)aindex[k];
		ans += a[i];
		if (i - 1 >= 0 && a[i - 1] > a[i]) ans += suf.Unite(i - 1, i) * a[i];
		if (i + 1 < N && a[i + 1] > a[i]) ans += suf.Unite(i + 1, i) * a[i];
	}
	ans.WL();
}
public struct SectionUnionFind
{
	private readonly int N;
	public int[] Parent { get; private set; }
	public long[] Cost { get; private set; }

	public SectionUnionFind(int n) {
		N = n;
		Parent = Enumerable.Range(0, N).ToArray();
		Cost = Enumerable.Repeat(1L, N).ToArray();
	}

	public int Root(int x) {
		return Parent[x] == x ? x : Parent[x] = Root(Parent[x]);
	}

	public long Unite(int x, int y) {
		x = Root(x);
		y = Root(y);
		var res = Cost[x] * Cost[y];
		Cost[x] += Cost[y];
		Parent[y] = x;
		return res;
	}
}
```

# AGC006 B Median Pyramid Easy
- あるマスの真下、右下、左下の中央値をそのマスに書いていくピラミッドで、頂点がXだったとき、N段目はどういう数列かを求める問題
  - ただし数列は`1~2N-1`の重複の無いもの
- Xが1か2N-1のとき不可能
  - 1は最小値、2N-1は最大値なので中央値になりえない
  - しかしそれ以外は可能
- N=2のとき
  - Xが2なら`{1,2,3}`が答え。それ以外は↑の例外にひっかかる
- N>2のとき、2段目の3マスのうち2マスがXなら頂点をXにできる
  - これを目指す
- N-1段目の中央とその隣（左右どちらでもいい）がXであったとき、その上のN-2段目も中央とその隣のマスはXになる。
  - N-3段目以降も同じ
- つまりN-1段目の中央とその隣のマスにXが来るような数列を考えればいいので
  - xは2N-2までの値をとるので `{...,x-1,x,x+1,x-2,...}` みたいな数列がある
  - ただしx=2のときは使えないので `{...,x+1,x,x-1,x+2,...}` に変えるといい
- あとはこれを出力すればAC

# AGC007 B Construct Sequences
- 昇順に並んだ数列Aと降順に並んだ数列Bがある。数列`P={p1,p2,...,pN}`に対して`A[p1]+B[p1] < A[p2]+B[p2] < ... < A[pN]+B[pN]`を満たすA,Bを求める問題
  - imosみたいな差分を取る方法を試したけど整合性をとれなかった
- 数列Cを`C={A[1]+B[1],A[2]+B[2],...,A[N]+B[N]}`とする。
  - このCが昇順に並んでればいい
  - 一番簡単なのは`{1,2,3,...}`だがA,Bも負数はありえないのでこれはできない
  - これをある程度シフトアップすることを考える。例えば `{401,402,403,...,400+N}` みたいなやつ。これなら作れそう
  - これをCのルールにする
- Cのルールを守りながらAとBの公差を固定化する。
- A,Bどちらかの数列は単純な倍数でいい。
  - `A={400,800,1200,...,400N}`とか
  - このときBも `{400N,400(N-1),...,400}`とするとCのルールが守られない
  - しかしCは全て同じ値になる
- なのでBの下の桁にPに出現した順番を記録する
  - 数列Rを`R[pi]=i`としたとき
  - Bを`B={400N+R[i],400(N-1)+R[i+1],...,400+R[N]}`とすれば、Cのルールを守る数列A,Bができる
- この400はどうやって求めるかというと適当な大きな数値でいい（解説だと30000だった）

# AGC008 B Contiguous Repainting
- AGCむずすぎる
- 連続するKマスを黒か白に塗る。最終的に黒だったマスに塗られている値が得点になり、その最大値を求める問題
- 最初にある区間を塗る。すると他のマスは自由に色塗りができる（1マスずらすだけでいい）
- これを利用してimosで解く
- imosは二種類確保する
  - そのままのimos
  - 正数だけのimos
- そのあとi(K<=i<=N)について
  - `ans = Utils.Utils.Max(ans, imosB[N] - (imosB[i] - imosB[i - K]) + (imosA[i] - imosA[i - K]),imosB[N] - (imosB[i] - imosB[i - K]));`
- を計算してAC

# AGC011 B Colorful Creatures
- 色iと大きさAiを持つモンスターがN体いる。大きさXiが2Yi以下なら大きさYiを持つモンスターを吸収し、色iのまま大きさがXi+Yiになる。最後の一体になったとき色の可能性としてあり得るのは何色か
  - PriorityQueueで小さい順に吸収させていって色を最大化するのかと思ったけど違った
- 先ずは大きさでソートする。
- 次に`2sum(k) < A[k+1]`となるようなkの最大値を探す。これをtとする。ない場合は0
  - このとき`{1,2,3,....t}`番目のモンスターの色が残るためには`t+1`番目を吸収しないといけない
  - しかし`{1,2,3,....t}`番目を合計してもそれはむりなのでここまでの色はなくなる
- 色の最大値はNであるのでこのtを引いた`N-t`が答え

# AGC015 B Evilator
- 各階には上に行くか下に行くかしか書いてないエレベータが設置されてる。全ての階からすべての階に行くのに必要なエレベータに乗る回数は何回か求める問題
  - エレベータを作ったやつは無能
- i階からj階に行くのにエレベータに乗る回数は1回か2回
  - i階に書いてあるボタンが`U`のとき
    - 下へ行くには2回乗る
    - 上に行くには1回乗る
  - i階に書いてあるボタンが`D`のときはその逆である
  - これらの計算は`O(1)`でできる
- これの合計が答え
```cs
S.ForeachWith((i, c) =>
{
	if (c=='U') {
		//下へ行くには2回乗る
		cnt += (i) * 2;
		//上に行くには1回乗る
		cnt += N - i - 1;
	}
	else {
		//下へ行くには1回乗る
		cnt += i;
		//上に行くには2回乗る
		cnt += (N - i-1) * 2;
	}
});
```